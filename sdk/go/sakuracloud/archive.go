// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sakuracloud

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Manages a SakuraCloud Archive.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-sakuracloud/sdk/go/sakuracloud"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := sakuracloud.NewArchive(ctx, "from_archive_or_disk", &sakuracloud.ArchiveArgs{
// 			Description:       pulumi.String("description"),
// 			SourceArchiveId:   pulumi.String("123456789012"),
// 			SourceArchiveZone: pulumi.String("tk1a"),
// 			Tags: pulumi.StringArray{
// 				pulumi.String("tag1"),
// 				pulumi.String("tag2"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sakuracloud.NewArchive(ctx, "from_shared_archive", &sakuracloud.ArchiveArgs{
// 			Description:     pulumi.String("description"),
// 			SourceSharedKey: pulumi.String("is1a:123456789012:xxx"),
// 			Tags: pulumi.StringArray{
// 				pulumi.String("tag1"),
// 				pulumi.String("tag2"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sakuracloud.NewArchive(ctx, "foobar", &sakuracloud.ArchiveArgs{
// 			ArchiveFile: pulumi.String("test/dummy.raw"),
// 			Description: pulumi.String("description"),
// 			Size:        pulumi.Int(20),
// 			Tags: pulumi.StringArray{
// 				pulumi.String("tag1"),
// 				pulumi.String("tag2"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type Archive struct {
	pulumi.CustomResourceState

	// The file path to upload to the SakuraCloud.
	ArchiveFile pulumi.StringPtrOutput `pulumi:"archiveFile"`
	// The description of the archive. The length of this value must be in the range [`1`-`512`].
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The md5 checksum calculated from the base64 encoded file body. Changing this forces a new resource to be created.
	Hash pulumi.StringOutput `pulumi:"hash"`
	// The icon id to attach to the archive.
	IconId pulumi.StringPtrOutput `pulumi:"iconId"`
	// The name of the archive. The length of this value must be in the range [`1`-`64`].
	Name pulumi.StringOutput `pulumi:"name"`
	// The size of archive in GiB. This must be one of [`20`/`40`/`60`/`80`/`100`/`250`/`500`/`750`/`1024`]. Changing this forces a new resource to be created. Default:`20`.
	Size pulumi.IntPtrOutput `pulumi:"size"`
	// The id of the source archive. This conflicts with [`sourceDiskId`]. Changing this forces a new resource to be created.
	SourceArchiveId pulumi.StringPtrOutput `pulumi:"sourceArchiveId"`
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceArchiveZone pulumi.StringPtrOutput `pulumi:"sourceArchiveZone"`
	// The id of the source disk. This conflicts with [`sourceArchiveId`]. Changing this forces a new resource to be created.
	SourceDiskId pulumi.StringPtrOutput `pulumi:"sourceDiskId"`
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceSharedKey pulumi.StringPtrOutput `pulumi:"sourceSharedKey"`
	// Any tags to assign to the archive.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The name of zone that the archive will be created. (e.g. `is1a`, `tk1a`). Changing this forces a new resource to be created.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewArchive registers a new resource with the given unique name, arguments, and options.
func NewArchive(ctx *pulumi.Context,
	name string, args *ArchiveArgs, opts ...pulumi.ResourceOption) (*Archive, error) {
	if args == nil {
		args = &ArchiveArgs{}
	}

	var resource Archive
	err := ctx.RegisterResource("sakuracloud:index/archive:Archive", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetArchive gets an existing Archive resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetArchive(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ArchiveState, opts ...pulumi.ResourceOption) (*Archive, error) {
	var resource Archive
	err := ctx.ReadResource("sakuracloud:index/archive:Archive", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Archive resources.
type archiveState struct {
	// The file path to upload to the SakuraCloud.
	ArchiveFile *string `pulumi:"archiveFile"`
	// The description of the archive. The length of this value must be in the range [`1`-`512`].
	Description *string `pulumi:"description"`
	// The md5 checksum calculated from the base64 encoded file body. Changing this forces a new resource to be created.
	Hash *string `pulumi:"hash"`
	// The icon id to attach to the archive.
	IconId *string `pulumi:"iconId"`
	// The name of the archive. The length of this value must be in the range [`1`-`64`].
	Name *string `pulumi:"name"`
	// The size of archive in GiB. This must be one of [`20`/`40`/`60`/`80`/`100`/`250`/`500`/`750`/`1024`]. Changing this forces a new resource to be created. Default:`20`.
	Size *int `pulumi:"size"`
	// The id of the source archive. This conflicts with [`sourceDiskId`]. Changing this forces a new resource to be created.
	SourceArchiveId *string `pulumi:"sourceArchiveId"`
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceArchiveZone *string `pulumi:"sourceArchiveZone"`
	// The id of the source disk. This conflicts with [`sourceArchiveId`]. Changing this forces a new resource to be created.
	SourceDiskId *string `pulumi:"sourceDiskId"`
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceSharedKey *string `pulumi:"sourceSharedKey"`
	// Any tags to assign to the archive.
	Tags []string `pulumi:"tags"`
	// The name of zone that the archive will be created. (e.g. `is1a`, `tk1a`). Changing this forces a new resource to be created.
	Zone *string `pulumi:"zone"`
}

type ArchiveState struct {
	// The file path to upload to the SakuraCloud.
	ArchiveFile pulumi.StringPtrInput
	// The description of the archive. The length of this value must be in the range [`1`-`512`].
	Description pulumi.StringPtrInput
	// The md5 checksum calculated from the base64 encoded file body. Changing this forces a new resource to be created.
	Hash pulumi.StringPtrInput
	// The icon id to attach to the archive.
	IconId pulumi.StringPtrInput
	// The name of the archive. The length of this value must be in the range [`1`-`64`].
	Name pulumi.StringPtrInput
	// The size of archive in GiB. This must be one of [`20`/`40`/`60`/`80`/`100`/`250`/`500`/`750`/`1024`]. Changing this forces a new resource to be created. Default:`20`.
	Size pulumi.IntPtrInput
	// The id of the source archive. This conflicts with [`sourceDiskId`]. Changing this forces a new resource to be created.
	SourceArchiveId pulumi.StringPtrInput
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceArchiveZone pulumi.StringPtrInput
	// The id of the source disk. This conflicts with [`sourceArchiveId`]. Changing this forces a new resource to be created.
	SourceDiskId pulumi.StringPtrInput
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceSharedKey pulumi.StringPtrInput
	// Any tags to assign to the archive.
	Tags pulumi.StringArrayInput
	// The name of zone that the archive will be created. (e.g. `is1a`, `tk1a`). Changing this forces a new resource to be created.
	Zone pulumi.StringPtrInput
}

func (ArchiveState) ElementType() reflect.Type {
	return reflect.TypeOf((*archiveState)(nil)).Elem()
}

type archiveArgs struct {
	// The file path to upload to the SakuraCloud.
	ArchiveFile *string `pulumi:"archiveFile"`
	// The description of the archive. The length of this value must be in the range [`1`-`512`].
	Description *string `pulumi:"description"`
	// The md5 checksum calculated from the base64 encoded file body. Changing this forces a new resource to be created.
	Hash *string `pulumi:"hash"`
	// The icon id to attach to the archive.
	IconId *string `pulumi:"iconId"`
	// The name of the archive. The length of this value must be in the range [`1`-`64`].
	Name *string `pulumi:"name"`
	// The size of archive in GiB. This must be one of [`20`/`40`/`60`/`80`/`100`/`250`/`500`/`750`/`1024`]. Changing this forces a new resource to be created. Default:`20`.
	Size *int `pulumi:"size"`
	// The id of the source archive. This conflicts with [`sourceDiskId`]. Changing this forces a new resource to be created.
	SourceArchiveId *string `pulumi:"sourceArchiveId"`
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceArchiveZone *string `pulumi:"sourceArchiveZone"`
	// The id of the source disk. This conflicts with [`sourceArchiveId`]. Changing this forces a new resource to be created.
	SourceDiskId *string `pulumi:"sourceDiskId"`
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceSharedKey *string `pulumi:"sourceSharedKey"`
	// Any tags to assign to the archive.
	Tags []string `pulumi:"tags"`
	// The name of zone that the archive will be created. (e.g. `is1a`, `tk1a`). Changing this forces a new resource to be created.
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a Archive resource.
type ArchiveArgs struct {
	// The file path to upload to the SakuraCloud.
	ArchiveFile pulumi.StringPtrInput
	// The description of the archive. The length of this value must be in the range [`1`-`512`].
	Description pulumi.StringPtrInput
	// The md5 checksum calculated from the base64 encoded file body. Changing this forces a new resource to be created.
	Hash pulumi.StringPtrInput
	// The icon id to attach to the archive.
	IconId pulumi.StringPtrInput
	// The name of the archive. The length of this value must be in the range [`1`-`64`].
	Name pulumi.StringPtrInput
	// The size of archive in GiB. This must be one of [`20`/`40`/`60`/`80`/`100`/`250`/`500`/`750`/`1024`]. Changing this forces a new resource to be created. Default:`20`.
	Size pulumi.IntPtrInput
	// The id of the source archive. This conflicts with [`sourceDiskId`]. Changing this forces a new resource to be created.
	SourceArchiveId pulumi.StringPtrInput
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceArchiveZone pulumi.StringPtrInput
	// The id of the source disk. This conflicts with [`sourceArchiveId`]. Changing this forces a new resource to be created.
	SourceDiskId pulumi.StringPtrInput
	// The share key of source shared archive. Changing this forces a new resource to be created.
	SourceSharedKey pulumi.StringPtrInput
	// Any tags to assign to the archive.
	Tags pulumi.StringArrayInput
	// The name of zone that the archive will be created. (e.g. `is1a`, `tk1a`). Changing this forces a new resource to be created.
	Zone pulumi.StringPtrInput
}

func (ArchiveArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*archiveArgs)(nil)).Elem()
}

type ArchiveInput interface {
	pulumi.Input

	ToArchiveOutput() ArchiveOutput
	ToArchiveOutputWithContext(ctx context.Context) ArchiveOutput
}

func (*Archive) ElementType() reflect.Type {
	return reflect.TypeOf((*Archive)(nil))
}

func (i *Archive) ToArchiveOutput() ArchiveOutput {
	return i.ToArchiveOutputWithContext(context.Background())
}

func (i *Archive) ToArchiveOutputWithContext(ctx context.Context) ArchiveOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchiveOutput)
}

func (i *Archive) ToArchivePtrOutput() ArchivePtrOutput {
	return i.ToArchivePtrOutputWithContext(context.Background())
}

func (i *Archive) ToArchivePtrOutputWithContext(ctx context.Context) ArchivePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePtrOutput)
}

type ArchivePtrInput interface {
	pulumi.Input

	ToArchivePtrOutput() ArchivePtrOutput
	ToArchivePtrOutputWithContext(ctx context.Context) ArchivePtrOutput
}

type archivePtrType ArchiveArgs

func (*archivePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Archive)(nil))
}

func (i *archivePtrType) ToArchivePtrOutput() ArchivePtrOutput {
	return i.ToArchivePtrOutputWithContext(context.Background())
}

func (i *archivePtrType) ToArchivePtrOutputWithContext(ctx context.Context) ArchivePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePtrOutput)
}

// ArchiveArrayInput is an input type that accepts ArchiveArray and ArchiveArrayOutput values.
// You can construct a concrete instance of `ArchiveArrayInput` via:
//
//          ArchiveArray{ ArchiveArgs{...} }
type ArchiveArrayInput interface {
	pulumi.Input

	ToArchiveArrayOutput() ArchiveArrayOutput
	ToArchiveArrayOutputWithContext(context.Context) ArchiveArrayOutput
}

type ArchiveArray []ArchiveInput

func (ArchiveArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*Archive)(nil))
}

func (i ArchiveArray) ToArchiveArrayOutput() ArchiveArrayOutput {
	return i.ToArchiveArrayOutputWithContext(context.Background())
}

func (i ArchiveArray) ToArchiveArrayOutputWithContext(ctx context.Context) ArchiveArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchiveArrayOutput)
}

// ArchiveMapInput is an input type that accepts ArchiveMap and ArchiveMapOutput values.
// You can construct a concrete instance of `ArchiveMapInput` via:
//
//          ArchiveMap{ "key": ArchiveArgs{...} }
type ArchiveMapInput interface {
	pulumi.Input

	ToArchiveMapOutput() ArchiveMapOutput
	ToArchiveMapOutputWithContext(context.Context) ArchiveMapOutput
}

type ArchiveMap map[string]ArchiveInput

func (ArchiveMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*Archive)(nil))
}

func (i ArchiveMap) ToArchiveMapOutput() ArchiveMapOutput {
	return i.ToArchiveMapOutputWithContext(context.Background())
}

func (i ArchiveMap) ToArchiveMapOutputWithContext(ctx context.Context) ArchiveMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchiveMapOutput)
}

type ArchiveOutput struct {
	*pulumi.OutputState
}

func (ArchiveOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Archive)(nil))
}

func (o ArchiveOutput) ToArchiveOutput() ArchiveOutput {
	return o
}

func (o ArchiveOutput) ToArchiveOutputWithContext(ctx context.Context) ArchiveOutput {
	return o
}

func (o ArchiveOutput) ToArchivePtrOutput() ArchivePtrOutput {
	return o.ToArchivePtrOutputWithContext(context.Background())
}

func (o ArchiveOutput) ToArchivePtrOutputWithContext(ctx context.Context) ArchivePtrOutput {
	return o.ApplyT(func(v Archive) *Archive {
		return &v
	}).(ArchivePtrOutput)
}

type ArchivePtrOutput struct {
	*pulumi.OutputState
}

func (ArchivePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Archive)(nil))
}

func (o ArchivePtrOutput) ToArchivePtrOutput() ArchivePtrOutput {
	return o
}

func (o ArchivePtrOutput) ToArchivePtrOutputWithContext(ctx context.Context) ArchivePtrOutput {
	return o
}

type ArchiveArrayOutput struct{ *pulumi.OutputState }

func (ArchiveArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Archive)(nil))
}

func (o ArchiveArrayOutput) ToArchiveArrayOutput() ArchiveArrayOutput {
	return o
}

func (o ArchiveArrayOutput) ToArchiveArrayOutputWithContext(ctx context.Context) ArchiveArrayOutput {
	return o
}

func (o ArchiveArrayOutput) Index(i pulumi.IntInput) ArchiveOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Archive {
		return vs[0].([]Archive)[vs[1].(int)]
	}).(ArchiveOutput)
}

type ArchiveMapOutput struct{ *pulumi.OutputState }

func (ArchiveMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Archive)(nil))
}

func (o ArchiveMapOutput) ToArchiveMapOutput() ArchiveMapOutput {
	return o
}

func (o ArchiveMapOutput) ToArchiveMapOutputWithContext(ctx context.Context) ArchiveMapOutput {
	return o
}

func (o ArchiveMapOutput) MapIndex(k pulumi.StringInput) ArchiveOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Archive {
		return vs[0].(map[string]Archive)[vs[1].(string)]
	}).(ArchiveOutput)
}

func init() {
	pulumi.RegisterOutputType(ArchiveOutput{})
	pulumi.RegisterOutputType(ArchivePtrOutput{})
	pulumi.RegisterOutputType(ArchiveArrayOutput{})
	pulumi.RegisterOutputType(ArchiveMapOutput{})
}
