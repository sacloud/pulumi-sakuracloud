# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'CertificateAuthorityClient',
    'CertificateAuthorityClientSubject',
    'CertificateAuthorityServer',
    'CertificateAuthorityServerSubject',
    'CertificateAuthoritySubject',
    'ContainerRegistryUser',
    'DNSRecord',
    'DatabaseBackup',
    'DatabaseNetworkInterface',
    'DatabaseReadReplicaNetworkInterface',
    'GSLBHealthCheck',
    'GSLBServer',
    'LoadBalancerNetworkInterface',
    'LoadBalancerVip',
    'LoadBalancerVipServer',
    'LocalRouterNetworkInterface',
    'LocalRouterPeer',
    'LocalRouterStaticRoute',
    'LocalRouterSwitch',
    'MobileGatewayPrivateNetworkInterface',
    'MobileGatewaySim',
    'MobileGatewaySimRoute',
    'MobileGatewayStaticRoute',
    'MobileGatewayTrafficControl',
    'NFSNetworkInterface',
    'PacketFilterExpression',
    'PacketFilterRuleExpression',
    'ProxyLBACMECertificate',
    'ProxyLBACMECertificateAdditionalCertificate',
    'ProxyLBBindPort',
    'ProxyLBBindPortResponseHeader',
    'ProxyLBCertificate',
    'ProxyLBCertificateAdditionalCertificate',
    'ProxyLBHealthCheck',
    'ProxyLBRule',
    'ProxyLBServer',
    'ProxyLBSorryServer',
    'ProxyLBSyslog',
    'ServerDiskEditParameter',
    'ServerDiskEditParameterNote',
    'ServerNetworkInterface',
    'SimpleMonitorHealthCheck',
    'VPCRouterDhcpServer',
    'VPCRouterDhcpStaticMapping',
    'VPCRouterFirewall',
    'VPCRouterFirewallExpression',
    'VPCRouterL2tp',
    'VPCRouterPortForwarding',
    'VPCRouterPptp',
    'VPCRouterPrivateNetworkInterface',
    'VPCRouterPublicNetworkInterface',
    'VPCRouterSiteToSiteVpn',
    'VPCRouterStaticNat',
    'VPCRouterStaticRoute',
    'VPCRouterUser',
    'VPCRouterWireGuard',
    'VPCRouterWireGuardPeer',
    'GetArchiveFilterResult',
    'GetArchiveFilterConditionResult',
    'GetBridgeFilterResult',
    'GetBridgeFilterConditionResult',
    'GetCDROMFilterResult',
    'GetCDROMFilterConditionResult',
    'GetCertificateAuthorityClientResult',
    'GetCertificateAuthorityFilterResult',
    'GetCertificateAuthorityFilterConditionResult',
    'GetCertificateAuthorityServerResult',
    'GetContainerRegistryFilterResult',
    'GetContainerRegistryFilterConditionResult',
    'GetContainerRegistryUserResult',
    'GetDNSFilterResult',
    'GetDNSFilterConditionResult',
    'GetDNSRecordResult',
    'GetDatabaseBackupResult',
    'GetDatabaseFilterResult',
    'GetDatabaseFilterConditionResult',
    'GetDatabaseNetworkInterfaceResult',
    'GetDiskFilterResult',
    'GetDiskFilterConditionResult',
    'GetESMEFilterResult',
    'GetESMEFilterConditionResult',
    'GetEnhancedDBFilterResult',
    'GetEnhancedDBFilterConditionResult',
    'GetGSLBFilterResult',
    'GetGSLBFilterConditionResult',
    'GetGSLBHealthCheckResult',
    'GetGSLBServerResult',
    'GetIconFilterResult',
    'GetIconFilterConditionResult',
    'GetInternetFilterResult',
    'GetInternetFilterConditionResult',
    'GetLoadBalancerFilterResult',
    'GetLoadBalancerFilterConditionResult',
    'GetLoadBalancerNetworkInterfaceResult',
    'GetLoadBalancerVipResult',
    'GetLoadBalancerVipServerResult',
    'GetLocalRouterFilterResult',
    'GetLocalRouterFilterConditionResult',
    'GetLocalRouterNetworkInterfaceResult',
    'GetLocalRouterPeerResult',
    'GetLocalRouterStaticRouteResult',
    'GetLocalRouterSwitchResult',
    'GetNFSFilterResult',
    'GetNFSFilterConditionResult',
    'GetNFSNetworkInterfaceResult',
    'GetNoteFilterResult',
    'GetNoteFilterConditionResult',
    'GetPacketFilterExpressionResult',
    'GetPacketFilterFilterResult',
    'GetPacketFilterFilterConditionResult',
    'GetPrivateHostFilterResult',
    'GetPrivateHostFilterConditionResult',
    'GetProxyLBBindPortResult',
    'GetProxyLBBindPortResponseHeaderResult',
    'GetProxyLBCertificateResult',
    'GetProxyLBCertificateAdditionalCertificateResult',
    'GetProxyLBFilterResult',
    'GetProxyLBFilterConditionResult',
    'GetProxyLBHealthCheckResult',
    'GetProxyLBRuleResult',
    'GetProxyLBServerResult',
    'GetProxyLBSorryServerResult',
    'GetProxyLBSyslogResult',
    'GetSSHKeyFilterResult',
    'GetSSHKeyFilterConditionResult',
    'GetServerFilterResult',
    'GetServerFilterConditionResult',
    'GetServerNetworkInterfaceResult',
    'GetSimpleMonitorFilterResult',
    'GetSimpleMonitorFilterConditionResult',
    'GetSimpleMonitorHealthCheckResult',
    'GetSwitchFilterResult',
    'GetSwitchFilterConditionResult',
    'GetVPCRouterDhcpServerResult',
    'GetVPCRouterDhcpStaticMappingResult',
    'GetVPCRouterFilterResult',
    'GetVPCRouterFilterConditionResult',
    'GetVPCRouterFirewallResult',
    'GetVPCRouterFirewallExpressionResult',
    'GetVPCRouterL2tpResult',
    'GetVPCRouterPortForwardingResult',
    'GetVPCRouterPptpResult',
    'GetVPCRouterPrivateNetworkInterfaceResult',
    'GetVPCRouterPublicNetworkInterfaceResult',
    'GetVPCRouterSiteToSiteVpnResult',
    'GetVPCRouterStaticNatResult',
    'GetVPCRouterStaticRouteResult',
    'GetVPCRouterUserResult',
    'GetVPCRouterWireGuardResult',
    'GetVPCRouterWireGuardPeerResult',
]

@pulumi.output_type
class CertificateAuthorityClient(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validityPeriodHours":
            suggest = "validity_period_hours"
        elif key == "issueState":
            suggest = "issue_state"
        elif key == "notAfter":
            suggest = "not_after"
        elif key == "notBefore":
            suggest = "not_before"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateAuthorityClient. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateAuthorityClient.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateAuthorityClient.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subject: 'outputs.CertificateAuthorityClientSubject',
                 validity_period_hours: int,
                 certificate: Optional[str] = None,
                 csr: Optional[str] = None,
                 email: Optional[str] = None,
                 hold: Optional[bool] = None,
                 id: Optional[str] = None,
                 issue_state: Optional[str] = None,
                 not_after: Optional[str] = None,
                 not_before: Optional[str] = None,
                 public_key: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param 'CertificateAuthorityClientSubjectArgs' subject: A `subject` block as defined below.
        :param int validity_period_hours: The number of hours after initial issuing that the certificate will become invalid.
        :param str certificate: The body of the CA's certificate in PEM format.
        :param str csr: Input for issuing a certificate.
        :param str email: Input for issuing a certificate.
        :param bool hold: Flag to suspend/hold the certificate.
        :param str id: The id of the certificate.
        :param str issue_state: Current state of the certificate.
        :param str not_after: The date on which the certificate validity period ends, in RFC3339 format.
        :param str not_before: The date on which the certificate validity period begins, in RFC3339 format.
        :param str public_key: Input for issuing a certificate.
        :param str serial_number: The body of the CA's certificate in PEM format.
        :param str url: The URL for issuing the certificate.
        """
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "validity_period_hours", validity_period_hours)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if csr is not None:
            pulumi.set(__self__, "csr", csr)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if hold is not None:
            pulumi.set(__self__, "hold", hold)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issue_state is not None:
            pulumi.set(__self__, "issue_state", issue_state)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def subject(self) -> 'outputs.CertificateAuthorityClientSubject':
        """
        A `subject` block as defined below.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="validityPeriodHours")
    def validity_period_hours(self) -> int:
        """
        The number of hours after initial issuing that the certificate will become invalid.
        """
        return pulumi.get(self, "validity_period_hours")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def csr(self) -> Optional[str]:
        """
        Input for issuing a certificate.
        """
        return pulumi.get(self, "csr")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Input for issuing a certificate.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def hold(self) -> Optional[bool]:
        """
        Flag to suspend/hold the certificate.
        """
        return pulumi.get(self, "hold")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the certificate.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issueState")
    def issue_state(self) -> Optional[str]:
        """
        Current state of the certificate.
        """
        return pulumi.get(self, "issue_state")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        """
        The date on which the certificate validity period ends, in RFC3339 format.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[str]:
        """
        The date on which the certificate validity period begins, in RFC3339 format.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        Input for issuing a certificate.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL for issuing the certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class CertificateAuthorityClientSubject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "organizationUnits":
            suggest = "organization_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateAuthorityClientSubject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateAuthorityClientSubject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateAuthorityClientSubject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str,
                 country: str,
                 organization: str,
                 organization_units: Optional[Sequence[str]] = None):
        """
        :param str common_name: .
        :param str country: .
        :param str organization: .
        :param Sequence[str] organization_units: .
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "organization", organization)
        if organization_units is not None:
            pulumi.set(__self__, "organization_units", organization_units)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        .
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        .
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        .
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationUnits")
    def organization_units(self) -> Optional[Sequence[str]]:
        """
        .
        """
        return pulumi.get(self, "organization_units")


@pulumi.output_type
class CertificateAuthorityServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validityPeriodHours":
            suggest = "validity_period_hours"
        elif key == "issueState":
            suggest = "issue_state"
        elif key == "notAfter":
            suggest = "not_after"
        elif key == "notBefore":
            suggest = "not_before"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateAuthorityServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateAuthorityServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateAuthorityServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subject: 'outputs.CertificateAuthorityServerSubject',
                 validity_period_hours: int,
                 certificate: Optional[str] = None,
                 csr: Optional[str] = None,
                 hold: Optional[bool] = None,
                 id: Optional[str] = None,
                 issue_state: Optional[str] = None,
                 not_after: Optional[str] = None,
                 not_before: Optional[str] = None,
                 public_key: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 subject_alternative_names: Optional[Sequence[str]] = None):
        """
        :param 'CertificateAuthorityServerSubjectArgs' subject: A `subject` block as defined below.
        :param int validity_period_hours: The number of hours after initial issuing that the certificate will become invalid.
        :param str certificate: The body of the CA's certificate in PEM format.
        :param str csr: Input for issuing a certificate.
        :param bool hold: Flag to suspend/hold the certificate.
        :param str id: The id of the certificate.
        :param str issue_state: Current state of the certificate.
        :param str not_after: The date on which the certificate validity period ends, in RFC3339 format.
        :param str not_before: The date on which the certificate validity period begins, in RFC3339 format.
        :param str public_key: Input for issuing a certificate.
        :param str serial_number: The body of the CA's certificate in PEM format.
        :param Sequence[str] subject_alternative_names: .
        """
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "validity_period_hours", validity_period_hours)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if csr is not None:
            pulumi.set(__self__, "csr", csr)
        if hold is not None:
            pulumi.set(__self__, "hold", hold)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if issue_state is not None:
            pulumi.set(__self__, "issue_state", issue_state)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def subject(self) -> 'outputs.CertificateAuthorityServerSubject':
        """
        A `subject` block as defined below.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="validityPeriodHours")
    def validity_period_hours(self) -> int:
        """
        The number of hours after initial issuing that the certificate will become invalid.
        """
        return pulumi.get(self, "validity_period_hours")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def csr(self) -> Optional[str]:
        """
        Input for issuing a certificate.
        """
        return pulumi.get(self, "csr")

    @property
    @pulumi.getter
    def hold(self) -> Optional[bool]:
        """
        Flag to suspend/hold the certificate.
        """
        return pulumi.get(self, "hold")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the certificate.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issueState")
    def issue_state(self) -> Optional[str]:
        """
        Current state of the certificate.
        """
        return pulumi.get(self, "issue_state")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        """
        The date on which the certificate validity period ends, in RFC3339 format.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[str]:
        """
        The date on which the certificate validity period begins, in RFC3339 format.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        Input for issuing a certificate.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[Sequence[str]]:
        """
        .
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class CertificateAuthorityServerSubject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "organizationUnits":
            suggest = "organization_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateAuthorityServerSubject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateAuthorityServerSubject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateAuthorityServerSubject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str,
                 country: str,
                 organization: str,
                 organization_units: Optional[Sequence[str]] = None):
        """
        :param str common_name: .
        :param str country: .
        :param str organization: .
        :param Sequence[str] organization_units: .
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "organization", organization)
        if organization_units is not None:
            pulumi.set(__self__, "organization_units", organization_units)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        .
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        .
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        .
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationUnits")
    def organization_units(self) -> Optional[Sequence[str]]:
        """
        .
        """
        return pulumi.get(self, "organization_units")


@pulumi.output_type
class CertificateAuthoritySubject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "organizationUnits":
            suggest = "organization_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateAuthoritySubject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateAuthoritySubject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateAuthoritySubject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str,
                 country: str,
                 organization: str,
                 organization_units: Optional[Sequence[str]] = None):
        """
        :param str common_name: .
        :param str country: .
        :param str organization: .
        :param Sequence[str] organization_units: .
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "organization", organization)
        if organization_units is not None:
            pulumi.set(__self__, "organization_units", organization_units)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        .
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        .
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        .
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationUnits")
    def organization_units(self) -> Optional[Sequence[str]]:
        """
        .
        """
        return pulumi.get(self, "organization_units")


@pulumi.output_type
class ContainerRegistryUser(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str,
                 permission: str):
        """
        :param str name: The user name used to authenticate remote access.
        :param str password: The password used to authenticate remote access.
        :param str permission: The level of access that allow to the user. This must be one of [`all`/`readwrite`/`readonly`].
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The user name used to authenticate remote access.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used to authenticate remote access.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        The level of access that allow to the user. This must be one of [`all`/`readwrite`/`readonly`].
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class DNSRecord(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str,
                 port: Optional[int] = None,
                 priority: Optional[int] = None,
                 ttl: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        :param str name: The name of the DNS Record. The length of this value must be in the range [`1`-`64`].
        :param str type: The type of DNS Record. This must be one of [`A`/`AAAA`/`ALIAS`/`CNAME`/`NS`/`MX`/`TXT`/`SRV`/`CAA`/`PTR`].
        :param str value: The value of the DNS Record.
        :param int port: The number of port. This must be in the range [`1`-`65535`].
        :param int priority: The priority of target DNS Record. This must be in the range [`0`-`65535`].
        :param int ttl: The number of the TTL.
        :param int weight: The weight of target DNS Record. This must be in the range [`0`-`65535`].
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the DNS Record. The length of this value must be in the range [`1`-`64`].
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of DNS Record. This must be one of [`A`/`AAAA`/`ALIAS`/`CNAME`/`NS`/`MX`/`TXT`/`SRV`/`CAA`/`PTR`].
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the DNS Record.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The number of port. This must be in the range [`1`-`65535`].
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority of target DNS Record. This must be in the range [`0`-`65535`].
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        The number of the TTL.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The weight of target DNS Record. This must be in the range [`0`-`65535`].
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DatabaseBackup(dict):
    def __init__(__self__, *,
                 time: Optional[str] = None,
                 weekdays: Optional[Sequence[str]] = None):
        """
        :param str time: The time to take backup. This must be formatted with `HH:mm`.
        :param Sequence[str] weekdays: A list of weekdays to backed up. The values in the list must be in [`sun`/`mon`/`tue`/`wed`/`thu`/`fri`/`sat`].
        """
        if time is not None:
            pulumi.set(__self__, "time", time)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        """
        The time to take backup. This must be formatted with `HH:mm`.
        """
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[str]]:
        """
        A list of weekdays to backed up. The values in the list must be in [`sun`/`mon`/`tue`/`wed`/`thu`/`fri`/`sat`].
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class DatabaseNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "switchId":
            suggest = "switch_id"
        elif key == "sourceRanges":
            suggest = "source_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: str,
                 ip_address: str,
                 netmask: int,
                 switch_id: str,
                 port: Optional[int] = None,
                 source_ranges: Optional[Sequence[str]] = None):
        """
        :param str gateway: The IP address of the gateway used by Database.
        :param str ip_address: The IP address to assign to the Database.
        :param int netmask: The bit length of the subnet to assign to the Database. This must be in the range [`8`-`29`].
        :param str switch_id: The id of the switch to which the Database connects.
        :param int port: The number of the listening port. This must be in the range [`1024`-`65535`].
        :param Sequence[str] source_ranges: The range of source IP addresses that allow to access to the Database via network.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_ranges is not None:
            pulumi.set(__self__, "source_ranges", source_ranges)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The IP address of the gateway used by Database.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address to assign to the Database.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet to assign to the Database. This must be in the range [`8`-`29`].
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch to which the Database connects.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The number of the listening port. This must be in the range [`1024`-`65535`].
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceRanges")
    def source_ranges(self) -> Optional[Sequence[str]]:
        """
        The range of source IP addresses that allow to access to the Database via network.
        """
        return pulumi.get(self, "source_ranges")


@pulumi.output_type
class DatabaseReadReplicaNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "sourceRanges":
            suggest = "source_ranges"
        elif key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseReadReplicaNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseReadReplicaNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseReadReplicaNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 gateway: Optional[str] = None,
                 netmask: Optional[int] = None,
                 source_ranges: Optional[Sequence[str]] = None,
                 switch_id: Optional[str] = None):
        """
        :param str ip_address: The IP address to assign to the read-replica database.
        :param str gateway: The IP address of the gateway used by read-replica database. If `gateway` isn't specified, it will be set to the same value of the master database.
        :param int netmask: The bit length of the subnet to assign to the read-replica database. This must be in the range [`8`-`29`]. If `netmask` isn't specified, it will be set to the same value of the master database.
        :param Sequence[str] source_ranges: The range of source IP addresses that allow to access to the read-replica database via network.
        :param str switch_id: The id of the switch to which the read-replica database connects. If `switch_id` isn't specified, it will be set to the same value of the master database.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if source_ranges is not None:
            pulumi.set(__self__, "source_ranges", source_ranges)
        if switch_id is not None:
            pulumi.set(__self__, "switch_id", switch_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address to assign to the read-replica database.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The IP address of the gateway used by read-replica database. If `gateway` isn't specified, it will be set to the same value of the master database.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[int]:
        """
        The bit length of the subnet to assign to the read-replica database. This must be in the range [`8`-`29`]. If `netmask` isn't specified, it will be set to the same value of the master database.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="sourceRanges")
    def source_ranges(self) -> Optional[Sequence[str]]:
        """
        The range of source IP addresses that allow to access to the read-replica database via network.
        """
        return pulumi.get(self, "source_ranges")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> Optional[str]:
        """
        The id of the switch to which the read-replica database connects. If `switch_id` isn't specified, it will be set to the same value of the master database.
        """
        return pulumi.get(self, "switch_id")


@pulumi.output_type
class GSLBHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayLoop":
            suggest = "delay_loop"
        elif key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GSLBHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GSLBHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GSLBHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 delay_loop: Optional[int] = None,
                 host_header: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 status: Optional[str] = None):
        """
        :param str protocol: The protocol used for health checks. This must be one of [`http`/`https`/`tcp`/`ping`].
        :param int delay_loop: The interval in seconds between checks. This must be in the range [`10`-`60`].
        :param str host_header: The value of host header send when checking by HTTP/HTTPS.
        :param str path: The path used when checking by HTTP/HTTPS.
        :param int port: The port number used when checking by TCP.
        :param str status: The response-code to expect when checking by HTTP/HTTPS.
        """
        pulumi.set(__self__, "protocol", protocol)
        if delay_loop is not None:
            pulumi.set(__self__, "delay_loop", delay_loop)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This must be one of [`http`/`https`/`tcp`/`ping`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="delayLoop")
    def delay_loop(self) -> Optional[int]:
        """
        The interval in seconds between checks. This must be in the range [`10`-`60`].
        """
        return pulumi.get(self, "delay_loop")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The value of host header send when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number used when checking by TCP.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The response-code to expect when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GSLBServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GSLBServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GSLBServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GSLBServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 enabled: Optional[bool] = None,
                 weight: Optional[int] = None):
        """
        :param str ip_address: The IP address of the server.
        :param bool enabled: The flag to enable as destination of load balancing.
        :param int weight: The weight used when weighted load balancing is enabled. This must be in the range [`1`-`10000`].
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the server.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The flag to enable as destination of load balancing.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The weight used when weighted load balancing is enabled. This must be in the range [`1`-`10000`].
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class LoadBalancerNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addresses: Sequence[str],
                 netmask: int,
                 switch_id: str,
                 vrid: int,
                 gateway: Optional[str] = None):
        """
        :param Sequence[str] ip_addresses: A list of IP address to assign to the LoadBalancer. .
        :param int netmask: The bit length of the subnet assigned to the LoadBalancer. This must be in the range [`8`-`29`].
        :param str switch_id: The id of the switch to which the LoadBalancer connects.
        :param int vrid: The Virtual Router Identifier.
        :param str gateway: The IP address of the gateway used by LoadBalancer.
        """
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)
        pulumi.set(__self__, "vrid", vrid)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A list of IP address to assign to the LoadBalancer. .
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet assigned to the LoadBalancer. This must be in the range [`8`-`29`].
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch to which the LoadBalancer connects.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def vrid(self) -> int:
        """
        The Virtual Router Identifier.
        """
        return pulumi.get(self, "vrid")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The IP address of the gateway used by LoadBalancer.
        """
        return pulumi.get(self, "gateway")


@pulumi.output_type
class LoadBalancerVip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayLoop":
            suggest = "delay_loop"
        elif key == "sorryServer":
            suggest = "sorry_server"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerVip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerVip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerVip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 vip: str,
                 delay_loop: Optional[int] = None,
                 description: Optional[str] = None,
                 servers: Optional[Sequence['outputs.LoadBalancerVipServer']] = None,
                 sorry_server: Optional[str] = None):
        """
        :param int port: The target port number for load-balancing. This must be in the range [`1`-`65535`].
        :param str vip: The virtual IP address.
        :param int delay_loop: The interval in seconds between checks. This must be in the range [`10`-`2147483647`].
        :param str description: The description of the VIP. The length of this value must be in the range [`1`-`512`].
        :param Sequence['LoadBalancerVipServerArgs'] servers: One or more `server` blocks as defined below.
        :param str sorry_server: The IP address of the SorryServer. This will be used when all servers under this VIP are down.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "vip", vip)
        if delay_loop is not None:
            pulumi.set(__self__, "delay_loop", delay_loop)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if sorry_server is not None:
            pulumi.set(__self__, "sorry_server", sorry_server)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The target port number for load-balancing. This must be in the range [`1`-`65535`].
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The virtual IP address.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter(name="delayLoop")
    def delay_loop(self) -> Optional[int]:
        """
        The interval in seconds between checks. This must be in the range [`10`-`2147483647`].
        """
        return pulumi.get(self, "delay_loop")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the VIP. The length of this value must be in the range [`1`-`512`].
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.LoadBalancerVipServer']]:
        """
        One or more `server` blocks as defined below.
        """
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter(name="sorryServer")
    def sorry_server(self) -> Optional[str]:
        """
        The IP address of the SorryServer. This will be used when all servers under this VIP are down.
        """
        return pulumi.get(self, "sorry_server")


@pulumi.output_type
class LoadBalancerVipServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerVipServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerVipServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerVipServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 protocol: str,
                 enabled: Optional[bool] = None,
                 path: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str ip_address: The IP address of the destination server.
        :param str protocol: The protocol used for health checks. This must be one of [`http`/`https`/`tcp`/`ping`].
        :param bool enabled: The flag to enable as destination of load balancing.
        :param str path: The path used when checking by HTTP/HTTPS.
        :param str status: The response code to expect when checking by HTTP/HTTPS.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "protocol", protocol)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the destination server.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This must be one of [`http`/`https`/`tcp`/`ping`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The flag to enable as destination of load balancing.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The response code to expect when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LocalRouterNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalRouterNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalRouterNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalRouterNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addresses: Sequence[str],
                 netmask: int,
                 vip: str,
                 vrid: int):
        """
        :param Sequence[str] ip_addresses: A list of IP address to assign to the LocalRouter.
        :param int netmask: The bit length of the subnet assigned to the LocalRouter. This must be in the range [`8`-`29`].
        :param str vip: The virtual IP address.
        :param int vrid: The Virtual Router Identifier.
        """
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vrid", vrid)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A list of IP address to assign to the LocalRouter.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet assigned to the LocalRouter. This must be in the range [`8`-`29`].
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The virtual IP address.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter
    def vrid(self) -> int:
        """
        The Virtual Router Identifier.
        """
        return pulumi.get(self, "vrid")


@pulumi.output_type
class LocalRouterPeer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerId":
            suggest = "peer_id"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalRouterPeer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalRouterPeer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalRouterPeer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 peer_id: str,
                 secret_key: str,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str peer_id: The ID of the peer LocalRouter.
        :param str secret_key: The secret key of the peer LocalRouter.
        :param str description: The description of the LocalRouter. The length of this value must be in the range [`1`-`512`].
        :param bool enabled: The flag to enable the LocalRouter.
        """
        pulumi.set(__self__, "peer_id", peer_id)
        pulumi.set(__self__, "secret_key", secret_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="peerId")
    def peer_id(self) -> str:
        """
        The ID of the peer LocalRouter.
        """
        return pulumi.get(self, "peer_id")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        The secret key of the peer LocalRouter.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the LocalRouter. The length of this value must be in the range [`1`-`512`].
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The flag to enable the LocalRouter.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LocalRouterStaticRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalRouterStaticRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalRouterStaticRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalRouterStaticRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop: str,
                 prefix: str):
        """
        :param str next_hop: The IP address of the next hop.
        :param str prefix: The CIDR block of destination.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The IP address of the next hop.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The CIDR block of destination.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class LocalRouterSwitch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalRouterSwitch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalRouterSwitch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalRouterSwitch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: str,
                 zone_id: str,
                 category: Optional[str] = None):
        """
        :param str code: The resource ID of the Switch.
        :param str zone_id: The id of the Zone.
        :param str category: The category name of connected services (e.g. `cloud`, `vps`).
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "zone_id", zone_id)
        if category is not None:
            pulumi.set(__self__, "category", category)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        The resource ID of the Switch.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The id of the Zone.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        The category name of connected services (e.g. `cloud`, `vps`).
        """
        return pulumi.get(self, "category")


@pulumi.output_type
class MobileGatewayPrivateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileGatewayPrivateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileGatewayPrivateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileGatewayPrivateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 netmask: int,
                 switch_id: str):
        """
        :param str ip_address: The IP address to assign to the MobileGateway.
        :param int netmask: The bit length of the subnet to assign to the MobileGateway. This must be in the range [`8`-`29`].
        :param str switch_id: The id of the switch to which the MobileGateway connects.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address to assign to the MobileGateway.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet to assign to the MobileGateway. This must be in the range [`8`-`29`].
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch to which the MobileGateway connects.
        """
        return pulumi.get(self, "switch_id")


@pulumi.output_type
class MobileGatewaySim(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "simId":
            suggest = "sim_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileGatewaySim. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileGatewaySim.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileGatewaySim.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 sim_id: str):
        """
        :param str ip_address: The IP address to assign to the SIM.
        :param str sim_id: The id of the Switch connected to the MobileGateway.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "sim_id", sim_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address to assign to the SIM.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="simId")
    def sim_id(self) -> str:
        """
        The id of the Switch connected to the MobileGateway.
        """
        return pulumi.get(self, "sim_id")


@pulumi.output_type
class MobileGatewaySimRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simId":
            suggest = "sim_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileGatewaySimRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileGatewaySimRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileGatewaySimRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix: str,
                 sim_id: str):
        """
        :param str prefix: The destination network prefix used by the sim routing. This must be specified by CIDR block formatted string.
        :param str sim_id: The id of the routing destination SIM.
        """
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "sim_id", sim_id)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The destination network prefix used by the sim routing. This must be specified by CIDR block formatted string.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="simId")
    def sim_id(self) -> str:
        """
        The id of the routing destination SIM.
        """
        return pulumi.get(self, "sim_id")


@pulumi.output_type
class MobileGatewayStaticRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileGatewayStaticRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileGatewayStaticRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileGatewayStaticRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop: str,
                 prefix: str):
        """
        :param str next_hop: The IP address of next hop.
        :param str prefix: The destination network prefix used by static routing. This must be specified by CIDR block formatted string.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The IP address of next hop.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The destination network prefix used by static routing. This must be specified by CIDR block formatted string.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class MobileGatewayTrafficControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoTrafficShaping":
            suggest = "auto_traffic_shaping"
        elif key == "bandWidthLimit":
            suggest = "band_width_limit"
        elif key == "enableEmail":
            suggest = "enable_email"
        elif key == "enableSlack":
            suggest = "enable_slack"
        elif key == "slackWebhook":
            suggest = "slack_webhook"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MobileGatewayTrafficControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MobileGatewayTrafficControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MobileGatewayTrafficControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quota: int,
                 auto_traffic_shaping: Optional[bool] = None,
                 band_width_limit: Optional[int] = None,
                 enable_email: Optional[bool] = None,
                 enable_slack: Optional[bool] = None,
                 slack_webhook: Optional[str] = None):
        """
        :param int quota: The threshold of monthly traffic usage to enable to the traffic shaping.
        :param bool auto_traffic_shaping: The flag to enable the traffic shaping.
        :param int band_width_limit: The bandwidth allowed when the traffic shaping is enabled.
        :param bool enable_email: The flag to enable email notification when the traffic shaping is enabled.
        :param bool enable_slack: The flag to enable slack notification when the traffic shaping is enabled.
        :param str slack_webhook: The webhook URL used when sends notification. It will only used when `enable_slack` is set `true`.
        """
        pulumi.set(__self__, "quota", quota)
        if auto_traffic_shaping is not None:
            pulumi.set(__self__, "auto_traffic_shaping", auto_traffic_shaping)
        if band_width_limit is not None:
            pulumi.set(__self__, "band_width_limit", band_width_limit)
        if enable_email is not None:
            pulumi.set(__self__, "enable_email", enable_email)
        if enable_slack is not None:
            pulumi.set(__self__, "enable_slack", enable_slack)
        if slack_webhook is not None:
            pulumi.set(__self__, "slack_webhook", slack_webhook)

    @property
    @pulumi.getter
    def quota(self) -> int:
        """
        The threshold of monthly traffic usage to enable to the traffic shaping.
        """
        return pulumi.get(self, "quota")

    @property
    @pulumi.getter(name="autoTrafficShaping")
    def auto_traffic_shaping(self) -> Optional[bool]:
        """
        The flag to enable the traffic shaping.
        """
        return pulumi.get(self, "auto_traffic_shaping")

    @property
    @pulumi.getter(name="bandWidthLimit")
    def band_width_limit(self) -> Optional[int]:
        """
        The bandwidth allowed when the traffic shaping is enabled.
        """
        return pulumi.get(self, "band_width_limit")

    @property
    @pulumi.getter(name="enableEmail")
    def enable_email(self) -> Optional[bool]:
        """
        The flag to enable email notification when the traffic shaping is enabled.
        """
        return pulumi.get(self, "enable_email")

    @property
    @pulumi.getter(name="enableSlack")
    def enable_slack(self) -> Optional[bool]:
        """
        The flag to enable slack notification when the traffic shaping is enabled.
        """
        return pulumi.get(self, "enable_slack")

    @property
    @pulumi.getter(name="slackWebhook")
    def slack_webhook(self) -> Optional[str]:
        """
        The webhook URL used when sends notification. It will only used when `enable_slack` is set `true`.
        """
        return pulumi.get(self, "slack_webhook")


@pulumi.output_type
class NFSNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NFSNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NFSNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NFSNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 netmask: int,
                 switch_id: str,
                 gateway: Optional[str] = None):
        """
        :param str ip_address: The IP address to assign to the NFS.
        :param int netmask: The bit length of the subnet to assign to the NFS. This must be in the range [`8`-`29`].
        :param str switch_id: The id of the switch to which the NFS connects.
        :param str gateway: The IP address of the gateway used by NFS.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address to assign to the NFS.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet to assign to the NFS. This must be in the range [`8`-`29`].
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch to which the NFS connects.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The IP address of the gateway used by NFS.
        """
        return pulumi.get(self, "gateway")


@pulumi.output_type
class PacketFilterExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPort":
            suggest = "destination_port"
        elif key == "sourceNetwork":
            suggest = "source_network"
        elif key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PacketFilterExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PacketFilterExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PacketFilterExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 allow: Optional[bool] = None,
                 description: Optional[str] = None,
                 destination_port: Optional[str] = None,
                 source_network: Optional[str] = None,
                 source_port: Optional[str] = None):
        """
        :param str protocol: The protocol used for filtering. This must be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`].
        :param bool allow: The flag to allow the packet through the filter.
        :param str description: The description of the packetFilter. The length of this value must be in the range [`1`-`512`].
        :param str destination_port: A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        :param str source_network: A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        :param str source_port: A source port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        pulumi.set(__self__, "protocol", protocol)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if source_network is not None:
            pulumi.set(__self__, "source_network", source_network)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for filtering. This must be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def allow(self) -> Optional[bool]:
        """
        The flag to allow the packet through the filter.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the packetFilter. The length of this value must be in the range [`1`-`512`].
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[str]:
        """
        A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter(name="sourceNetwork")
    def source_network(self) -> Optional[str]:
        """
        A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        """
        return pulumi.get(self, "source_network")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[str]:
        """
        A source port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        return pulumi.get(self, "source_port")


@pulumi.output_type
class PacketFilterRuleExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPort":
            suggest = "destination_port"
        elif key == "sourceNetwork":
            suggest = "source_network"
        elif key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PacketFilterRuleExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PacketFilterRuleExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PacketFilterRuleExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 allow: Optional[bool] = None,
                 description: Optional[str] = None,
                 destination_port: Optional[str] = None,
                 source_network: Optional[str] = None,
                 source_port: Optional[str] = None):
        """
        :param str protocol: The protocol used for filtering. This must be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`].
        :param bool allow: The flag to allow the packet through the filter.
        :param str description: The description of the expression.
        :param str destination_port: A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        :param str source_network: A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        :param str source_port: A source port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        pulumi.set(__self__, "protocol", protocol)
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if source_network is not None:
            pulumi.set(__self__, "source_network", source_network)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for filtering. This must be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def allow(self) -> Optional[bool]:
        """
        The flag to allow the packet through the filter.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the expression.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[str]:
        """
        A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter(name="sourceNetwork")
    def source_network(self) -> Optional[str]:
        """
        A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        """
        return pulumi.get(self, "source_network")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[str]:
        """
        A source port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        return pulumi.get(self, "source_port")


@pulumi.output_type
class ProxyLBACMECertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalCertificates":
            suggest = "additional_certificates"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "intermediateCert":
            suggest = "intermediate_cert"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "serverCert":
            suggest = "server_cert"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBACMECertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBACMECertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBACMECertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_certificates: Optional[Sequence['outputs.ProxyLBACMECertificateAdditionalCertificate']] = None,
                 common_name: Optional[str] = None,
                 intermediate_cert: Optional[str] = None,
                 private_key: Optional[str] = None,
                 server_cert: Optional[str] = None,
                 subject_alt_names: Optional[str] = None):
        """
        :param Sequence['ProxyLBACMECertificateAdditionalCertificateArgs'] additional_certificates: A list of `additional_certificate` blocks as defined below.
        :param str common_name: The FQDN used by ACME. This must set resolvable value. Changing this forces a new resource to be created.
        :param str intermediate_cert: The intermediate certificate for a server.
        :param str private_key: The private key for a server.
        :param str server_cert: The certificate for a server.
        :param str subject_alt_names: The Subject alternative names used by ACME. Changing this forces a new resource to be created.
        """
        if additional_certificates is not None:
            pulumi.set(__self__, "additional_certificates", additional_certificates)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if intermediate_cert is not None:
            pulumi.set(__self__, "intermediate_cert", intermediate_cert)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if server_cert is not None:
            pulumi.set(__self__, "server_cert", server_cert)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="additionalCertificates")
    def additional_certificates(self) -> Optional[Sequence['outputs.ProxyLBACMECertificateAdditionalCertificate']]:
        """
        A list of `additional_certificate` blocks as defined below.
        """
        return pulumi.get(self, "additional_certificates")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        """
        The FQDN used by ACME. This must set resolvable value. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="intermediateCert")
    def intermediate_cert(self) -> Optional[str]:
        """
        The intermediate certificate for a server.
        """
        return pulumi.get(self, "intermediate_cert")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        The private key for a server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> Optional[str]:
        """
        The certificate for a server.
        """
        return pulumi.get(self, "server_cert")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[str]:
        """
        The Subject alternative names used by ACME. Changing this forces a new resource to be created.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class ProxyLBACMECertificateAdditionalCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intermediateCert":
            suggest = "intermediate_cert"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "serverCert":
            suggest = "server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBACMECertificateAdditionalCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBACMECertificateAdditionalCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBACMECertificateAdditionalCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intermediate_cert: Optional[str] = None,
                 private_key: Optional[str] = None,
                 server_cert: Optional[str] = None):
        """
        :param str intermediate_cert: The intermediate certificate for a server.
        :param str private_key: The private key for a server.
        :param str server_cert: The certificate for a server.
        """
        if intermediate_cert is not None:
            pulumi.set(__self__, "intermediate_cert", intermediate_cert)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if server_cert is not None:
            pulumi.set(__self__, "server_cert", server_cert)

    @property
    @pulumi.getter(name="intermediateCert")
    def intermediate_cert(self) -> Optional[str]:
        """
        The intermediate certificate for a server.
        """
        return pulumi.get(self, "intermediate_cert")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        The private key for a server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> Optional[str]:
        """
        The certificate for a server.
        """
        return pulumi.get(self, "server_cert")


@pulumi.output_type
class ProxyLBBindPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "proxyMode":
            suggest = "proxy_mode"
        elif key == "redirectToHttps":
            suggest = "redirect_to_https"
        elif key == "responseHeaders":
            suggest = "response_headers"
        elif key == "sslPolicy":
            suggest = "ssl_policy"
        elif key == "supportHttp2":
            suggest = "support_http2"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBBindPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBBindPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBBindPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 proxy_mode: str,
                 port: Optional[int] = None,
                 redirect_to_https: Optional[bool] = None,
                 response_headers: Optional[Sequence['outputs.ProxyLBBindPortResponseHeader']] = None,
                 ssl_policy: Optional[str] = None,
                 support_http2: Optional[bool] = None):
        """
        :param str proxy_mode: The proxy mode. This must be one of [`http`/`https`/`tcp`].
        :param int port: The number of listening port.
        :param bool redirect_to_https: The flag to enable redirection from http to https. This flag is used only when `proxy_mode` is `http`.
        :param Sequence['ProxyLBBindPortResponseHeaderArgs'] response_headers: One or more `response_header` blocks as defined below.
        :param str ssl_policy: The ssl policy. This must be one of [`TLS-1-2-2019-04`/`TLS-1-2-2021-06`/`TLS-1-3-2021-06`].
        :param bool support_http2: The flag to enable HTTP/2. This flag is used only when `proxy_mode` is `https`.
        """
        pulumi.set(__self__, "proxy_mode", proxy_mode)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if redirect_to_https is not None:
            pulumi.set(__self__, "redirect_to_https", redirect_to_https)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)
        if ssl_policy is not None:
            pulumi.set(__self__, "ssl_policy", ssl_policy)
        if support_http2 is not None:
            pulumi.set(__self__, "support_http2", support_http2)

    @property
    @pulumi.getter(name="proxyMode")
    def proxy_mode(self) -> str:
        """
        The proxy mode. This must be one of [`http`/`https`/`tcp`].
        """
        return pulumi.get(self, "proxy_mode")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The number of listening port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="redirectToHttps")
    def redirect_to_https(self) -> Optional[bool]:
        """
        The flag to enable redirection from http to https. This flag is used only when `proxy_mode` is `http`.
        """
        return pulumi.get(self, "redirect_to_https")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.ProxyLBBindPortResponseHeader']]:
        """
        One or more `response_header` blocks as defined below.
        """
        return pulumi.get(self, "response_headers")

    @property
    @pulumi.getter(name="sslPolicy")
    def ssl_policy(self) -> Optional[str]:
        """
        The ssl policy. This must be one of [`TLS-1-2-2019-04`/`TLS-1-2-2021-06`/`TLS-1-3-2021-06`].
        """
        return pulumi.get(self, "ssl_policy")

    @property
    @pulumi.getter(name="supportHttp2")
    def support_http2(self) -> Optional[bool]:
        """
        The flag to enable HTTP/2. This flag is used only when `proxy_mode` is `https`.
        """
        return pulumi.get(self, "support_http2")


@pulumi.output_type
class ProxyLBBindPortResponseHeader(dict):
    def __init__(__self__, *,
                 header: str,
                 value: str):
        """
        :param str header: The field name of HTTP header added to response by the ProxyLB.
        :param str value: The field value of HTTP header added to response by the ProxyLB.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        The field name of HTTP header added to response by the ProxyLB.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The field value of HTTP header added to response by the ProxyLB.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProxyLBCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalCertificates":
            suggest = "additional_certificates"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "intermediateCert":
            suggest = "intermediate_cert"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "serverCert":
            suggest = "server_cert"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_certificates: Optional[Sequence['outputs.ProxyLBCertificateAdditionalCertificate']] = None,
                 common_name: Optional[str] = None,
                 intermediate_cert: Optional[str] = None,
                 private_key: Optional[str] = None,
                 server_cert: Optional[str] = None,
                 subject_alt_names: Optional[str] = None):
        """
        :param Sequence['ProxyLBCertificateAdditionalCertificateArgs'] additional_certificates: One or more `additional_certificate` blocks as defined below.
        :param str common_name: The common name of the certificate.
        :param str intermediate_cert: The intermediate certificate for a server.
        :param str private_key: The private key for a server.
        :param str server_cert: The certificate for a server.
        :param str subject_alt_names: The subject alternative names of the certificate.
        """
        if additional_certificates is not None:
            pulumi.set(__self__, "additional_certificates", additional_certificates)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if intermediate_cert is not None:
            pulumi.set(__self__, "intermediate_cert", intermediate_cert)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if server_cert is not None:
            pulumi.set(__self__, "server_cert", server_cert)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="additionalCertificates")
    def additional_certificates(self) -> Optional[Sequence['outputs.ProxyLBCertificateAdditionalCertificate']]:
        """
        One or more `additional_certificate` blocks as defined below.
        """
        return pulumi.get(self, "additional_certificates")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        """
        The common name of the certificate.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="intermediateCert")
    def intermediate_cert(self) -> Optional[str]:
        """
        The intermediate certificate for a server.
        """
        return pulumi.get(self, "intermediate_cert")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        The private key for a server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> Optional[str]:
        """
        The certificate for a server.
        """
        return pulumi.get(self, "server_cert")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[str]:
        """
        The subject alternative names of the certificate.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class ProxyLBCertificateAdditionalCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "serverCert":
            suggest = "server_cert"
        elif key == "intermediateCert":
            suggest = "intermediate_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBCertificateAdditionalCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBCertificateAdditionalCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBCertificateAdditionalCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key: str,
                 server_cert: str,
                 intermediate_cert: Optional[str] = None):
        """
        :param str private_key: The private key for a server.
        :param str server_cert: The certificate for a server.
        :param str intermediate_cert: The intermediate certificate for a server.
        """
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "server_cert", server_cert)
        if intermediate_cert is not None:
            pulumi.set(__self__, "intermediate_cert", intermediate_cert)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        The private key for a server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> str:
        """
        The certificate for a server.
        """
        return pulumi.get(self, "server_cert")

    @property
    @pulumi.getter(name="intermediateCert")
    def intermediate_cert(self) -> Optional[str]:
        """
        The intermediate certificate for a server.
        """
        return pulumi.get(self, "intermediate_cert")


@pulumi.output_type
class ProxyLBHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayLoop":
            suggest = "delay_loop"
        elif key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 delay_loop: Optional[int] = None,
                 host_header: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str protocol: The protocol used for health checks. This must be one of [`http`/`tcp`].
        :param int delay_loop: The interval in seconds between checks. This must be in the range [`10`-`60`].
        :param str host_header: The value of host header send when checking by HTTP.
        :param str path: The path used when checking by HTTP.
        :param int port: The port number used when checking by TCP.
        """
        pulumi.set(__self__, "protocol", protocol)
        if delay_loop is not None:
            pulumi.set(__self__, "delay_loop", delay_loop)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This must be one of [`http`/`tcp`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="delayLoop")
    def delay_loop(self) -> Optional[int]:
        """
        The interval in seconds between checks. This must be in the range [`10`-`60`].
        """
        return pulumi.get(self, "delay_loop")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The value of host header send when checking by HTTP.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path used when checking by HTTP.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number used when checking by TCP.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ProxyLBRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedContentType":
            suggest = "fixed_content_type"
        elif key == "fixedMessageBody":
            suggest = "fixed_message_body"
        elif key == "fixedStatusCode":
            suggest = "fixed_status_code"
        elif key == "redirectLocation":
            suggest = "redirect_location"
        elif key == "redirectStatusCode":
            suggest = "redirect_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 fixed_content_type: Optional[str] = None,
                 fixed_message_body: Optional[str] = None,
                 fixed_status_code: Optional[str] = None,
                 group: Optional[str] = None,
                 host: Optional[str] = None,
                 path: Optional[str] = None,
                 redirect_location: Optional[str] = None,
                 redirect_status_code: Optional[str] = None):
        """
        :param str action: The type of action to be performed when requests matches the rule. This must be one of [`forward`/`redirect`/`fixed`] Default: `forward`.
        :param str fixed_content_type: Content-Type header value for fixed response sent when requests matches the rule. This must be one of [`text/plain`/`text/html`/`application/javascript`/`application/json`].
        :param str fixed_message_body: Content body for fixed response sent when requests matches the rule.
        :param str fixed_status_code: HTTP status code for fixed response sent when requests matches the rule. This must be one of [`200`/`403`/`503`].
        :param str group: The name of load balancing group. When proxyLB received request which matched to `host` and `path`, proxyLB forwards the request to servers that having same group name. The length of this value must be in the range [`1`-`10`].
        :param str host: The value of HTTP host header that is used as condition of rule-based balancing.
        :param str path: The request path that is used as condition of rule-based balancing.
        :param str redirect_location: The URL to redirect to when the request matches the rule. see https://manual.sakura.ad.jp/cloud/appliance/enhanced-lb/#enhanced-lb-rule for details.
        :param str redirect_status_code: HTTP status code for redirects sent when requests matches the rule. This must be one of [`301`/`302`].
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if fixed_content_type is not None:
            pulumi.set(__self__, "fixed_content_type", fixed_content_type)
        if fixed_message_body is not None:
            pulumi.set(__self__, "fixed_message_body", fixed_message_body)
        if fixed_status_code is not None:
            pulumi.set(__self__, "fixed_status_code", fixed_status_code)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if redirect_location is not None:
            pulumi.set(__self__, "redirect_location", redirect_location)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The type of action to be performed when requests matches the rule. This must be one of [`forward`/`redirect`/`fixed`] Default: `forward`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="fixedContentType")
    def fixed_content_type(self) -> Optional[str]:
        """
        Content-Type header value for fixed response sent when requests matches the rule. This must be one of [`text/plain`/`text/html`/`application/javascript`/`application/json`].
        """
        return pulumi.get(self, "fixed_content_type")

    @property
    @pulumi.getter(name="fixedMessageBody")
    def fixed_message_body(self) -> Optional[str]:
        """
        Content body for fixed response sent when requests matches the rule.
        """
        return pulumi.get(self, "fixed_message_body")

    @property
    @pulumi.getter(name="fixedStatusCode")
    def fixed_status_code(self) -> Optional[str]:
        """
        HTTP status code for fixed response sent when requests matches the rule. This must be one of [`200`/`403`/`503`].
        """
        return pulumi.get(self, "fixed_status_code")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The name of load balancing group. When proxyLB received request which matched to `host` and `path`, proxyLB forwards the request to servers that having same group name. The length of this value must be in the range [`1`-`10`].
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The value of HTTP host header that is used as condition of rule-based balancing.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The request path that is used as condition of rule-based balancing.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="redirectLocation")
    def redirect_location(self) -> Optional[str]:
        """
        The URL to redirect to when the request matches the rule. see https://manual.sakura.ad.jp/cloud/appliance/enhanced-lb/#enhanced-lb-rule for details.
        """
        return pulumi.get(self, "redirect_location")

    @property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[str]:
        """
        HTTP status code for redirects sent when requests matches the rule. This must be one of [`301`/`302`].
        """
        return pulumi.get(self, "redirect_status_code")


@pulumi.output_type
class ProxyLBServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 port: int,
                 enabled: Optional[bool] = None,
                 group: Optional[str] = None):
        """
        :param str ip_address: The IP address of the destination server.
        :param int port: The port number of the destination server. This must be in the range [`1`-`65535`].
        :param bool enabled: The flag to enable as destination of load balancing.
        :param str group: The name of load balancing group. This is used when using rule-based load balancing. The length of this value must be in the range [`1`-`10`].
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "port", port)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the destination server.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number of the destination server. This must be in the range [`1`-`65535`].
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The flag to enable as destination of load balancing.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The name of load balancing group. This is used when using rule-based load balancing. The length of this value must be in the range [`1`-`10`].
        """
        return pulumi.get(self, "group")


@pulumi.output_type
class ProxyLBSorryServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyLBSorryServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyLBSorryServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyLBSorryServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 port: Optional[int] = None):
        """
        :param str ip_address: The IP address of the SorryServer. This will be used when all servers are down.
        :param int port: The port number of the SorryServer. This will be used when all servers are down.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the SorryServer. This will be used when all servers are down.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number of the SorryServer. This will be used when all servers are down.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ProxyLBSyslog(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None,
                 server: Optional[str] = None):
        """
        :param int port: The number of syslog port.
        :param str server: The address of syslog server.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The number of syslog port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        The address of syslog server.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class ServerDiskEditParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changePartitionUuid":
            suggest = "change_partition_uuid"
        elif key == "disablePwAuth":
            suggest = "disable_pw_auth"
        elif key == "enableDhcp":
            suggest = "enable_dhcp"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "noteIds":
            suggest = "note_ids"
        elif key == "sshKeyIds":
            suggest = "ssh_key_ids"
        elif key == "sshKeys":
            suggest = "ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerDiskEditParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerDiskEditParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerDiskEditParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_partition_uuid: Optional[bool] = None,
                 disable_pw_auth: Optional[bool] = None,
                 enable_dhcp: Optional[bool] = None,
                 gateway: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 netmask: Optional[int] = None,
                 note_ids: Optional[Sequence[str]] = None,
                 notes: Optional[Sequence['outputs.ServerDiskEditParameterNote']] = None,
                 password: Optional[str] = None,
                 ssh_key_ids: Optional[Sequence[str]] = None,
                 ssh_keys: Optional[Sequence[str]] = None):
        """
        :param bool change_partition_uuid: The flag to change partition uuid.
        :param bool disable_pw_auth: The flag to disable password authentication.
        :param bool enable_dhcp: The flag to enable DHCP client.
        :param str gateway: The gateway address used by the Server.
        :param str hostname: The hostname of the Server. The length of this value must be in the range [`1`-`64`].
        :param str ip_address: The IP address to assign to the Server.
        :param int netmask: The bit length of the subnet to assign to the Server.
        :param Sequence[str] note_ids: A list of the Note id.  
               Note: **The `note_ids` will be removed in a future version. Please use the `note` instead**
        :param Sequence['ServerDiskEditParameterNoteArgs'] notes: A list of the `note` block as defined below.
        :param str password: The password of default user. The length of this value must be in the range [`8`-`64`].
        :param Sequence[str] ssh_key_ids: A list of the SSHKey id.
        :param Sequence[str] ssh_keys: A list of the SSHKey text.
        """
        if change_partition_uuid is not None:
            pulumi.set(__self__, "change_partition_uuid", change_partition_uuid)
        if disable_pw_auth is not None:
            pulumi.set(__self__, "disable_pw_auth", disable_pw_auth)
        if enable_dhcp is not None:
            pulumi.set(__self__, "enable_dhcp", enable_dhcp)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if note_ids is not None:
            pulumi.set(__self__, "note_ids", note_ids)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_key_ids is not None:
            pulumi.set(__self__, "ssh_key_ids", ssh_key_ids)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter(name="changePartitionUuid")
    def change_partition_uuid(self) -> Optional[bool]:
        """
        The flag to change partition uuid.
        """
        return pulumi.get(self, "change_partition_uuid")

    @property
    @pulumi.getter(name="disablePwAuth")
    def disable_pw_auth(self) -> Optional[bool]:
        """
        The flag to disable password authentication.
        """
        return pulumi.get(self, "disable_pw_auth")

    @property
    @pulumi.getter(name="enableDhcp")
    def enable_dhcp(self) -> Optional[bool]:
        """
        The flag to enable DHCP client.
        """
        return pulumi.get(self, "enable_dhcp")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The gateway address used by the Server.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The hostname of the Server. The length of this value must be in the range [`1`-`64`].
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address to assign to the Server.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[int]:
        """
        The bit length of the subnet to assign to the Server.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="noteIds")
    def note_ids(self) -> Optional[Sequence[str]]:
        """
        A list of the Note id.  
        Note: **The `note_ids` will be removed in a future version. Please use the `note` instead**
        """
        return pulumi.get(self, "note_ids")

    @property
    @pulumi.getter
    def notes(self) -> Optional[Sequence['outputs.ServerDiskEditParameterNote']]:
        """
        A list of the `note` block as defined below.
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password of default user. The length of this value must be in the range [`8`-`64`].
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshKeyIds")
    def ssh_key_ids(self) -> Optional[Sequence[str]]:
        """
        A list of the SSHKey id.
        """
        return pulumi.get(self, "ssh_key_ids")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        A list of the SSHKey text.
        """
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class ServerDiskEditParameterNote(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyId":
            suggest = "api_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerDiskEditParameterNote. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerDiskEditParameterNote.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerDiskEditParameterNote.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 api_key_id: Optional[str] = None,
                 variables: Optional[Mapping[str, str]] = None):
        """
        :param str id: The id of the Note/StartupScript.
        :param str api_key_id: The id of the API key to be injected into the Note/StartupScript when editing the disk.
        :param Mapping[str, str] variables: The value of the variable that be injected into the Note/StartupScript when editing the disk.
        """
        pulumi.set(__self__, "id", id)
        if api_key_id is not None:
            pulumi.set(__self__, "api_key_id", api_key_id)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Note/StartupScript.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> Optional[str]:
        """
        The id of the API key to be injected into the Note/StartupScript when editing the disk.
        """
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, str]]:
        """
        The value of the variable that be injected into the Note/StartupScript when editing the disk.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class ServerNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macAddress":
            suggest = "mac_address"
        elif key == "packetFilterId":
            suggest = "packet_filter_id"
        elif key == "userIpAddress":
            suggest = "user_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upstream: str,
                 mac_address: Optional[str] = None,
                 packet_filter_id: Optional[str] = None,
                 user_ip_address: Optional[str] = None):
        """
        :param str upstream: The upstream type or upstream switch id. This must be one of [`shared`/`disconnect`/`<switch id>`].
        :param str mac_address: The MAC address.
        :param str packet_filter_id: The id of the packet filter to attach to the network interface.
        :param str user_ip_address: The IP address for only display. This value doesn't affect actual NIC settings.
        """
        pulumi.set(__self__, "upstream", upstream)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if packet_filter_id is not None:
            pulumi.set(__self__, "packet_filter_id", packet_filter_id)
        if user_ip_address is not None:
            pulumi.set(__self__, "user_ip_address", user_ip_address)

    @property
    @pulumi.getter
    def upstream(self) -> str:
        """
        The upstream type or upstream switch id. This must be one of [`shared`/`disconnect`/`<switch id>`].
        """
        return pulumi.get(self, "upstream")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The MAC address.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="packetFilterId")
    def packet_filter_id(self) -> Optional[str]:
        """
        The id of the packet filter to attach to the network interface.
        """
        return pulumi.get(self, "packet_filter_id")

    @property
    @pulumi.getter(name="userIpAddress")
    def user_ip_address(self) -> Optional[str]:
        """
        The IP address for only display. This value doesn't affect actual NIC settings.
        """
        return pulumi.get(self, "user_ip_address")


@pulumi.output_type
class SimpleMonitorHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containsString":
            suggest = "contains_string"
        elif key == "excepctedData":
            suggest = "excepcted_data"
        elif key == "hostHeader":
            suggest = "host_header"
        elif key == "remainingDays":
            suggest = "remaining_days"
        elif key == "snmpVersion":
            suggest = "snmp_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SimpleMonitorHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SimpleMonitorHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SimpleMonitorHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 community: Optional[str] = None,
                 contains_string: Optional[str] = None,
                 excepcted_data: Optional[str] = None,
                 ftps: Optional[str] = None,
                 host_header: Optional[str] = None,
                 http2: Optional[bool] = None,
                 oid: Optional[str] = None,
                 password: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 qname: Optional[str] = None,
                 remaining_days: Optional[int] = None,
                 sni: Optional[bool] = None,
                 snmp_version: Optional[str] = None,
                 status: Optional[int] = None,
                 username: Optional[str] = None):
        """
        :param str protocol: The protocol used for health checks. This must be one of [`http`/`https`/`ping`/`tcp`/`dns`/`ssh`/`smtp`/`pop3`/`snmp`/`sslcertificate`/`ftp`].
        :param str community: The SNMP community string used when checking by SNMP.
        :param str contains_string: The string that should be included in the response body when checking for HTTP/HTTPS.
        :param str excepcted_data: The expected value used when checking by DNS.
        :param str ftps: The methods of invoking security for monitoring with FTPS. This must be one of [``/`implicit`/`explicit`].
        :param str host_header: The value of host header send when checking by HTTP/HTTPS.
        :param bool http2: The flag to enable HTTP/2 when checking by HTTPS.
        :param str oid: The SNMP OID used when checking by SNMP.
        :param str password: The password for basic auth used when checking by HTTP/HTTPS.
        :param str path: The path used when checking by HTTP/HTTPS.
        :param int port: The target port number.
        :param str qname: The FQDN used when checking by DNS.
        :param int remaining_days: The number of remaining days until certificate expiration used when checking SSL certificates. This must be in the range [`1`-`9999`].
        :param bool sni: The flag to enable SNI when checking by HTTP/HTTPS.
        :param str snmp_version: The SNMP version used when checking by SNMP. This must be one of `1`/`2c`.
        :param int status: The response-code to expect when checking by HTTP/HTTPS.
        :param str username: The user name for basic auth used when checking by HTTP/HTTPS.
        """
        pulumi.set(__self__, "protocol", protocol)
        if community is not None:
            pulumi.set(__self__, "community", community)
        if contains_string is not None:
            pulumi.set(__self__, "contains_string", contains_string)
        if excepcted_data is not None:
            pulumi.set(__self__, "excepcted_data", excepcted_data)
        if ftps is not None:
            pulumi.set(__self__, "ftps", ftps)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if oid is not None:
            pulumi.set(__self__, "oid", oid)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if qname is not None:
            pulumi.set(__self__, "qname", qname)
        if remaining_days is not None:
            pulumi.set(__self__, "remaining_days", remaining_days)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if snmp_version is not None:
            pulumi.set(__self__, "snmp_version", snmp_version)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This must be one of [`http`/`https`/`ping`/`tcp`/`dns`/`ssh`/`smtp`/`pop3`/`snmp`/`sslcertificate`/`ftp`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def community(self) -> Optional[str]:
        """
        The SNMP community string used when checking by SNMP.
        """
        return pulumi.get(self, "community")

    @property
    @pulumi.getter(name="containsString")
    def contains_string(self) -> Optional[str]:
        """
        The string that should be included in the response body when checking for HTTP/HTTPS.
        """
        return pulumi.get(self, "contains_string")

    @property
    @pulumi.getter(name="excepctedData")
    def excepcted_data(self) -> Optional[str]:
        """
        The expected value used when checking by DNS.
        """
        return pulumi.get(self, "excepcted_data")

    @property
    @pulumi.getter
    def ftps(self) -> Optional[str]:
        """
        The methods of invoking security for monitoring with FTPS. This must be one of [``/`implicit`/`explicit`].
        """
        return pulumi.get(self, "ftps")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The value of host header send when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def http2(self) -> Optional[bool]:
        """
        The flag to enable HTTP/2 when checking by HTTPS.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def oid(self) -> Optional[str]:
        """
        The SNMP OID used when checking by SNMP.
        """
        return pulumi.get(self, "oid")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for basic auth used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The target port number.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def qname(self) -> Optional[str]:
        """
        The FQDN used when checking by DNS.
        """
        return pulumi.get(self, "qname")

    @property
    @pulumi.getter(name="remainingDays")
    def remaining_days(self) -> Optional[int]:
        """
        The number of remaining days until certificate expiration used when checking SSL certificates. This must be in the range [`1`-`9999`].
        """
        return pulumi.get(self, "remaining_days")

    @property
    @pulumi.getter
    def sni(self) -> Optional[bool]:
        """
        The flag to enable SNI when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="snmpVersion")
    def snmp_version(self) -> Optional[str]:
        """
        The SNMP version used when checking by SNMP. This must be one of `1`/`2c`.
        """
        return pulumi.get(self, "snmp_version")

    @property
    @pulumi.getter
    def status(self) -> Optional[int]:
        """
        The response-code to expect when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The user name for basic auth used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VPCRouterDhcpServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceIndex":
            suggest = "interface_index"
        elif key == "rangeStart":
            suggest = "range_start"
        elif key == "rangeStop":
            suggest = "range_stop"
        elif key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterDhcpServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterDhcpServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterDhcpServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_index: int,
                 range_start: str,
                 range_stop: str,
                 dns_servers: Optional[Sequence[str]] = None):
        """
        :param int interface_index: The index of the network interface on which to enable the DHCP service. This must be in the range [`1`-`7`].
        :param str range_start: The start value of IP address range to assign to DHCP client.
        :param str range_stop: The end value of IP address range to assign to DHCP client.
        :param Sequence[str] dns_servers: A list of IP address of DNS server to assign to DHCP client.
        """
        pulumi.set(__self__, "interface_index", interface_index)
        pulumi.set(__self__, "range_start", range_start)
        pulumi.set(__self__, "range_stop", range_stop)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="interfaceIndex")
    def interface_index(self) -> int:
        """
        The index of the network interface on which to enable the DHCP service. This must be in the range [`1`-`7`].
        """
        return pulumi.get(self, "interface_index")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> str:
        """
        The start value of IP address range to assign to DHCP client.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter(name="rangeStop")
    def range_stop(self) -> str:
        """
        The end value of IP address range to assign to DHCP client.
        """
        return pulumi.get(self, "range_stop")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of IP address of DNS server to assign to DHCP client.
        """
        return pulumi.get(self, "dns_servers")


@pulumi.output_type
class VPCRouterDhcpStaticMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterDhcpStaticMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterDhcpStaticMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterDhcpStaticMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 mac_address: str):
        """
        :param str ip_address: The static IP address to assign to DHCP client.
        :param str mac_address: The source MAC address of static mapping.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The static IP address to assign to DHCP client.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The source MAC address of static mapping.
        """
        return pulumi.get(self, "mac_address")


@pulumi.output_type
class VPCRouterFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceIndex":
            suggest = "interface_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: str,
                 expressions: Sequence['outputs.VPCRouterFirewallExpression'],
                 interface_index: Optional[int] = None):
        """
        :param str direction: The direction to apply the firewall. This must be one of [`send`/`receive`].
        :param Sequence['VPCRouterFirewallExpressionArgs'] expressions: One or more `expression` blocks as defined below.
        :param int interface_index: The index of the network interface on which to enable filtering. This must be in the range [`0`-`7`].
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "expressions", expressions)
        if interface_index is not None:
            pulumi.set(__self__, "interface_index", interface_index)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction to apply the firewall. This must be one of [`send`/`receive`].
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['outputs.VPCRouterFirewallExpression']:
        """
        One or more `expression` blocks as defined below.
        """
        return pulumi.get(self, "expressions")

    @property
    @pulumi.getter(name="interfaceIndex")
    def interface_index(self) -> Optional[int]:
        """
        The index of the network interface on which to enable filtering. This must be in the range [`0`-`7`].
        """
        return pulumi.get(self, "interface_index")


@pulumi.output_type
class VPCRouterFirewallExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationNetwork":
            suggest = "destination_network"
        elif key == "destinationPort":
            suggest = "destination_port"
        elif key == "sourceNetwork":
            suggest = "source_network"
        elif key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterFirewallExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterFirewallExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterFirewallExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: bool,
                 protocol: str,
                 description: Optional[str] = None,
                 destination_network: Optional[str] = None,
                 destination_port: Optional[str] = None,
                 logging: Optional[bool] = None,
                 source_network: Optional[str] = None,
                 source_port: Optional[str] = None):
        """
        :param bool allow: The flag to allow the packet through the filter.
        :param str protocol: The protocol used for filtering. This must be one of [`tcp`/`udp`/`icmp`/`ip`].
        :param str description: The description of the expression. The length of this value must be in the range [`0`-`512`].
        :param str destination_network: A destination IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        :param str destination_port: A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        :param bool logging: The flag to enable packet logging when matching the expression.
        :param str source_network: A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        :param str source_port: A source port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        """
        pulumi.set(__self__, "allow", allow)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_network is not None:
            pulumi.set(__self__, "destination_network", destination_network)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if source_network is not None:
            pulumi.set(__self__, "source_network", source_network)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def allow(self) -> bool:
        """
        The flag to allow the packet through the filter.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for filtering. This must be one of [`tcp`/`udp`/`icmp`/`ip`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the expression. The length of this value must be in the range [`0`-`512`].
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationNetwork")
    def destination_network(self) -> Optional[str]:
        """
        A destination IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        """
        return pulumi.get(self, "destination_network")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[str]:
        """
        A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def logging(self) -> Optional[bool]:
        """
        The flag to enable packet logging when matching the expression.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="sourceNetwork")
    def source_network(self) -> Optional[str]:
        """
        A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        """
        return pulumi.get(self, "source_network")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[str]:
        """
        A source port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        """
        return pulumi.get(self, "source_port")


@pulumi.output_type
class VPCRouterL2tp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preSharedSecret":
            suggest = "pre_shared_secret"
        elif key == "rangeStart":
            suggest = "range_start"
        elif key == "rangeStop":
            suggest = "range_stop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterL2tp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterL2tp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterL2tp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pre_shared_secret: str,
                 range_start: str,
                 range_stop: str):
        """
        :param str pre_shared_secret: The pre shared secret for the VPN. The length of this value must be in the range [`0`-`40`].
        :param str range_start: The start value of IP address range to assign to DHCP client.
        :param str range_stop: The end value of IP address range to assign to DHCP client.
        """
        pulumi.set(__self__, "pre_shared_secret", pre_shared_secret)
        pulumi.set(__self__, "range_start", range_start)
        pulumi.set(__self__, "range_stop", range_stop)

    @property
    @pulumi.getter(name="preSharedSecret")
    def pre_shared_secret(self) -> str:
        """
        The pre shared secret for the VPN. The length of this value must be in the range [`0`-`40`].
        """
        return pulumi.get(self, "pre_shared_secret")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> str:
        """
        The start value of IP address range to assign to DHCP client.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter(name="rangeStop")
    def range_stop(self) -> str:
        """
        The end value of IP address range to assign to DHCP client.
        """
        return pulumi.get(self, "range_stop")


@pulumi.output_type
class VPCRouterPortForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"
        elif key == "privatePort":
            suggest = "private_port"
        elif key == "publicPort":
            suggest = "public_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterPortForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterPortForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterPortForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip: str,
                 private_port: int,
                 protocol: str,
                 public_port: int,
                 description: Optional[str] = None):
        """
        :param str private_ip: The destination ip address of the port forwarding.
        :param int private_port: The destination port number of the port forwarding. This will be a port number on a private network.
        :param str protocol: The protocol used for port forwarding. This must be one of [`tcp`/`udp`].
        :param int public_port: The source port number of the port forwarding. This must be a port number on a public network.
        :param str description: The description of the port forwarding. The length of this value must be in the range [`0`-`512`].
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "private_port", private_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_port", public_port)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The destination ip address of the port forwarding.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="privatePort")
    def private_port(self) -> int:
        """
        The destination port number of the port forwarding. This will be a port number on a private network.
        """
        return pulumi.get(self, "private_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for port forwarding. This must be one of [`tcp`/`udp`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> int:
        """
        The source port number of the port forwarding. This must be a port number on a public network.
        """
        return pulumi.get(self, "public_port")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the port forwarding. The length of this value must be in the range [`0`-`512`].
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class VPCRouterPptp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeStart":
            suggest = "range_start"
        elif key == "rangeStop":
            suggest = "range_stop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterPptp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterPptp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterPptp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_start: str,
                 range_stop: str):
        """
        :param str range_start: The start value of IP address range to assign to PPTP client.
        :param str range_stop: The end value of IP address range to assign to PPTP client.
        """
        pulumi.set(__self__, "range_start", range_start)
        pulumi.set(__self__, "range_stop", range_stop)

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> str:
        """
        The start value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter(name="rangeStop")
    def range_stop(self) -> str:
        """
        The end value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_stop")


@pulumi.output_type
class VPCRouterPrivateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterPrivateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterPrivateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterPrivateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: int,
                 ip_addresses: Sequence[str],
                 netmask: int,
                 switch_id: str,
                 vip: Optional[str] = None):
        """
        :param int index: The index of the network interface. This must be in the range [`1`-`7`].
        :param Sequence[str] ip_addresses: A list of ip address to assign to the network interface. This is required only one value when `plan` is `standard`, two values otherwise.
        :param int netmask: The bit length of the subnet to assign to the network interface.
        :param str switch_id: The id of the connected switch.
        :param str vip: The virtual IP address to assign to the network interface. This is only required when `plan` is not `standard`.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The index of the network interface. This must be in the range [`1`-`7`].
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A list of ip address to assign to the network interface. This is required only one value when `plan` is `standard`, two values otherwise.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet to assign to the network interface.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the connected switch.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def vip(self) -> Optional[str]:
        """
        The virtual IP address to assign to the network interface. This is only required when `plan` is not `standard`.
        """
        return pulumi.get(self, "vip")


@pulumi.output_type
class VPCRouterPublicNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterPublicNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterPublicNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterPublicNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aliases: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None,
                 switch_id: Optional[str] = None,
                 vip: Optional[str] = None,
                 vrid: Optional[int] = None):
        """
        :param Sequence[str] aliases: A list of ip alias to assign to the VPC Router. This can only be specified if `plan` is not `standard`.
        :param Sequence[str] ip_addresses: The list of the IP address to assign to the VPC Router. This is required only one value when `plan` is `standard`, two values otherwise.
        :param str switch_id: The id of the switch to connect. This is only required when when `plan` is not `standard`.
        :param str vip: The virtual IP address of the VPC Router. This is only required when `plan` is not `standard`.
        :param int vrid: The Virtual Router Identifier. This is only required when `plan` is not `standard`.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if switch_id is not None:
            pulumi.set(__self__, "switch_id", switch_id)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)
        if vrid is not None:
            pulumi.set(__self__, "vrid", vrid)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence[str]]:
        """
        A list of ip alias to assign to the VPC Router. This can only be specified if `plan` is not `standard`.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        The list of the IP address to assign to the VPC Router. This is required only one value when `plan` is `standard`, two values otherwise.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> Optional[str]:
        """
        The id of the switch to connect. This is only required when when `plan` is not `standard`.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def vip(self) -> Optional[str]:
        """
        The virtual IP address of the VPC Router. This is only required when `plan` is not `standard`.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter
    def vrid(self) -> Optional[int]:
        """
        The Virtual Router Identifier. This is only required when `plan` is not `standard`.
        """
        return pulumi.get(self, "vrid")


@pulumi.output_type
class VPCRouterSiteToSiteVpn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localPrefixes":
            suggest = "local_prefixes"
        elif key == "preSharedSecret":
            suggest = "pre_shared_secret"
        elif key == "remoteId":
            suggest = "remote_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterSiteToSiteVpn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterSiteToSiteVpn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterSiteToSiteVpn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_prefixes: Sequence[str],
                 peer: str,
                 pre_shared_secret: str,
                 remote_id: str,
                 routes: Sequence[str]):
        """
        :param Sequence[str] local_prefixes: A list of CIDR block of the network under the VPC Router.
        :param str peer: The IP address of the opposing appliance connected to the VPC Router.
        :param str pre_shared_secret: The pre shared secret for the VPN. The length of this value must be in the range [`0`-`40`].
        :param str remote_id: The id of the opposing appliance connected to the VPC Router. This is typically set same as value of `peer`.
        :param Sequence[str] routes: A list of CIDR block of VPN connected networks.
        """
        pulumi.set(__self__, "local_prefixes", local_prefixes)
        pulumi.set(__self__, "peer", peer)
        pulumi.set(__self__, "pre_shared_secret", pre_shared_secret)
        pulumi.set(__self__, "remote_id", remote_id)
        pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter(name="localPrefixes")
    def local_prefixes(self) -> Sequence[str]:
        """
        A list of CIDR block of the network under the VPC Router.
        """
        return pulumi.get(self, "local_prefixes")

    @property
    @pulumi.getter
    def peer(self) -> str:
        """
        The IP address of the opposing appliance connected to the VPC Router.
        """
        return pulumi.get(self, "peer")

    @property
    @pulumi.getter(name="preSharedSecret")
    def pre_shared_secret(self) -> str:
        """
        The pre shared secret for the VPN. The length of this value must be in the range [`0`-`40`].
        """
        return pulumi.get(self, "pre_shared_secret")

    @property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> str:
        """
        The id of the opposing appliance connected to the VPC Router. This is typically set same as value of `peer`.
        """
        return pulumi.get(self, "remote_id")

    @property
    @pulumi.getter
    def routes(self) -> Sequence[str]:
        """
        A list of CIDR block of VPN connected networks.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class VPCRouterStaticNat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIp":
            suggest = "private_ip"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterStaticNat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterStaticNat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterStaticNat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip: str,
                 public_ip: str,
                 description: Optional[str] = None):
        """
        :param str private_ip: The private IP address used for the static NAT.
        :param str public_ip: The public IP address used for the static NAT.
        :param str description: The description of the static nat. The length of this value must be in the range [`0`-`512`].
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "public_ip", public_ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address used for the static NAT.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IP address used for the static NAT.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the static nat. The length of this value must be in the range [`0`-`512`].
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class VPCRouterStaticRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHop":
            suggest = "next_hop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterStaticRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterStaticRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterStaticRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop: str,
                 prefix: str):
        """
        :param str next_hop: The IP address of the next hop.
        :param str prefix: The CIDR block of destination.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The IP address of the next hop.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The CIDR block of destination.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class VPCRouterUser(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The user name used to authenticate remote access.
        :param str password: The password used to authenticate remote access.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The user name used to authenticate remote access.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used to authenticate remote access.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class VPCRouterWireGuard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterWireGuard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterWireGuard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterWireGuard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 peers: Optional[Sequence['outputs.VPCRouterWireGuardPeer']] = None,
                 public_key: Optional[str] = None):
        """
        :param str ip_address: The IP address for WireGuard server. This must be formatted with xxx.xxx.xxx.xxx/nn.
        :param Sequence['VPCRouterWireGuardPeerArgs'] peers: One or more `peer` blocks as defined below.
        :param str public_key: the public key of the WireGuard client.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if peers is not None:
            pulumi.set(__self__, "peers", peers)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address for WireGuard server. This must be formatted with xxx.xxx.xxx.xxx/nn.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def peers(self) -> Optional[Sequence['outputs.VPCRouterWireGuardPeer']]:
        """
        One or more `peer` blocks as defined below.
        """
        return pulumi.get(self, "peers")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        the public key of the WireGuard client.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class VPCRouterWireGuardPeer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCRouterWireGuardPeer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCRouterWireGuardPeer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCRouterWireGuardPeer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 name: str,
                 public_key: str):
        """
        :param str ip_address: The IP address for peer.
        :param str name: the of the peer.
        :param str public_key: the public key of the WireGuard client.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address for peer.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the of the peer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        the public key of the WireGuard client.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetArchiveFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetArchiveFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetArchiveFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetArchiveFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetArchiveFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetBridgeFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetBridgeFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetBridgeFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetBridgeFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class GetBridgeFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCDROMFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetCDROMFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetCDROMFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetCDROMFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCDROMFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCertificateAuthorityClientResult(dict):
    def __init__(__self__, *,
                 certificate: str,
                 hold: bool,
                 id: str,
                 issue_state: str,
                 not_after: str,
                 not_before: str,
                 serial_number: str,
                 subject_string: str,
                 url: str):
        """
        :param str certificate: The body of the CA's certificate in PEM format.
        :param bool hold: Flag to suspend/hold the certificate.
        :param str id: The resource id on SakuraCloud used for filtering.
        :param str issue_state: Current state of the certificate.
        :param str not_after: The date on which the certificate validity period ends, in RFC3339 format.
        :param str not_before: The date on which the certificate validity period begins, in RFC3339 format.
        :param str serial_number: The body of the CA's certificate in PEM format.
        :param str subject_string: .
        :param str url: The URL for issuing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "hold", hold)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issue_state", issue_state)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "subject_string", subject_string)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def hold(self) -> bool:
        """
        Flag to suspend/hold the certificate.
        """
        return pulumi.get(self, "hold")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issueState")
    def issue_state(self) -> str:
        """
        Current state of the certificate.
        """
        return pulumi.get(self, "issue_state")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        The date on which the certificate validity period ends, in RFC3339 format.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        The date on which the certificate validity period begins, in RFC3339 format.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> str:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="subjectString")
    def subject_string(self) -> str:
        """
        .
        """
        return pulumi.get(self, "subject_string")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL for issuing the certificate.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetCertificateAuthorityFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetCertificateAuthorityFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetCertificateAuthorityFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetCertificateAuthorityFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCertificateAuthorityFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetCertificateAuthorityServerResult(dict):
    def __init__(__self__, *,
                 certificate: str,
                 id: str,
                 issue_state: str,
                 not_after: str,
                 not_before: str,
                 serial_number: str,
                 subject_alternative_names: Sequence[str],
                 subject_string: str,
                 hold: Optional[bool] = None):
        """
        :param str certificate: The body of the CA's certificate in PEM format.
        :param str id: The resource id on SakuraCloud used for filtering.
        :param str issue_state: Current state of the certificate.
        :param str not_after: The date on which the certificate validity period ends, in RFC3339 format.
        :param str not_before: The date on which the certificate validity period begins, in RFC3339 format.
        :param str serial_number: The body of the CA's certificate in PEM format.
        :param Sequence[str] subject_alternative_names: .
        :param str subject_string: .
        :param bool hold: Flag to suspend/hold the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issue_state", issue_state)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        pulumi.set(__self__, "subject_string", subject_string)
        if hold is not None:
            pulumi.set(__self__, "hold", hold)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="issueState")
    def issue_state(self) -> str:
        """
        Current state of the certificate.
        """
        return pulumi.get(self, "issue_state")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        The date on which the certificate validity period ends, in RFC3339 format.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        The date on which the certificate validity period begins, in RFC3339 format.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> str:
        """
        The body of the CA's certificate in PEM format.
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence[str]:
        """
        .
        """
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter(name="subjectString")
    def subject_string(self) -> str:
        """
        .
        """
        return pulumi.get(self, "subject_string")

    @property
    @pulumi.getter
    def hold(self) -> Optional[bool]:
        """
        Flag to suspend/hold the certificate.
        """
        return pulumi.get(self, "hold")


@pulumi.output_type
class GetContainerRegistryFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetContainerRegistryFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetContainerRegistryFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetContainerRegistryFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetContainerRegistryFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetContainerRegistryUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permission: str):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param str permission: The level of access that allow to the user. This will be one of [`all`/`readwrite`/`readonly`].
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        The level of access that allow to the user. This will be one of [`all`/`readwrite`/`readonly`].
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetDNSFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetDNSFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetDNSFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetDNSFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetDNSFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDNSRecordResult(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int,
                 priority: int,
                 ttl: int,
                 type: str,
                 value: str,
                 weight: int):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param int port: The number of port.
        :param int priority: The priority of target DNS Record.
        :param int ttl: The number of the TTL.
        :param str type: The type of DNS Record. This will be one of [`A`/`AAAA`/`ALIAS`/`CNAME`/`NS`/`MX`/`TXT`/`SRV`/`CAA`/`PTR`].
        :param str value: The value of the DNS Record.
        :param int weight: The weight of target DNS Record.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The number of port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of target DNS Record.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def ttl(self) -> int:
        """
        The number of the TTL.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of DNS Record. This will be one of [`A`/`AAAA`/`ALIAS`/`CNAME`/`NS`/`MX`/`TXT`/`SRV`/`CAA`/`PTR`].
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the DNS Record.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of target DNS Record.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetDatabaseBackupResult(dict):
    def __init__(__self__, *,
                 time: str,
                 weekdays: Sequence[str]):
        """
        :param str time: The time to take backup. This will be formatted with `HH:mm`.
        :param Sequence[str] weekdays: The list of name of weekday that doing backup. This will be in [`sun`/`mon`/`tue`/`wed`/`thu`/`fri`/`sat`].
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time to take backup. This will be formatted with `HH:mm`.
        """
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def weekdays(self) -> Sequence[str]:
        """
        The list of name of weekday that doing backup. This will be in [`sun`/`mon`/`tue`/`wed`/`thu`/`fri`/`sat`].
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class GetDatabaseFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetDatabaseFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetDatabaseFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetDatabaseFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetDatabaseFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDatabaseNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 gateway: str,
                 ip_address: str,
                 netmask: int,
                 port: int,
                 source_ranges: Sequence[str],
                 switch_id: str):
        """
        :param str gateway: The IP address of the gateway used by Database.
        :param str ip_address: The IP address assigned to the Database.
        :param int netmask: The bit length of the subnet assigned to the Database.
        :param int port: The number of the listening port.
        :param Sequence[str] source_ranges: The range of source IP addresses that allow to access to the Database via network.
        :param str switch_id: The id of the switch connected from the Database.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "source_ranges", source_ranges)
        pulumi.set(__self__, "switch_id", switch_id)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The IP address of the gateway used by Database.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address assigned to the Database.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet assigned to the Database.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The number of the listening port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceRanges")
    def source_ranges(self) -> Sequence[str]:
        """
        The range of source IP addresses that allow to access to the Database via network.
        """
        return pulumi.get(self, "source_ranges")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch connected from the Database.
        """
        return pulumi.get(self, "switch_id")


@pulumi.output_type
class GetDiskFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetDiskFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetDiskFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetDiskFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetDiskFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetESMEFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetESMEFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetESMEFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetESMEFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetESMEFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetEnhancedDBFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetEnhancedDBFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetEnhancedDBFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetEnhancedDBFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetEnhancedDBFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGSLBFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetGSLBFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetGSLBFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetGSLBFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetGSLBFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGSLBHealthCheckResult(dict):
    def __init__(__self__, *,
                 delay_loop: int,
                 host_header: str,
                 path: str,
                 port: int,
                 protocol: str,
                 status: str):
        """
        :param int delay_loop: The interval in seconds between checks.
        :param str host_header: The value of host header send when checking by HTTP/HTTPS.
        :param str path: The path used when checking by HTTP/HTTPS.
        :param int port: The port number used when checking by TCP.
        :param str protocol: The protocol used for health checks. This will be one of [`http`/`https`/`tcp`/`ping`].
        :param str status: The response-code to expect when checking by HTTP/HTTPS.
        """
        pulumi.set(__self__, "delay_loop", delay_loop)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="delayLoop")
    def delay_loop(self) -> int:
        """
        The interval in seconds between checks.
        """
        return pulumi.get(self, "delay_loop")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The value of host header send when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port number used when checking by TCP.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This will be one of [`http`/`https`/`tcp`/`ping`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The response-code to expect when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGSLBServerResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 ip_address: str,
                 weight: int):
        """
        :param bool enabled: The flag to enable as destination of load balancing.
        :param str ip_address: The IP address of the server.
        :param int weight: The weight used when weighted load balancing is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The flag to enable as destination of load balancing.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the server.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight used when weighted load balancing is enabled.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetIconFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetIconFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetIconFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetIconFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetIconFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetInternetFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetInternetFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetInternetFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetInternetFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetInternetFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLoadBalancerFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetLoadBalancerFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetLoadBalancerFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetLoadBalancerFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLoadBalancerFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLoadBalancerNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 gateway: str,
                 ip_addresses: Sequence[str],
                 netmask: int,
                 switch_id: str,
                 vrid: int):
        """
        :param str gateway: The IP address of the gateway used by LoadBalancer.
        :param Sequence[str] ip_addresses: The list of IP address assigned to the LoadBalancer.
        :param int netmask: The bit length of the subnet assigned to the LoadBalancer.
        :param str switch_id: The id of the switch connected from the LoadBalancer.
        :param int vrid: The Virtual Router Identifier.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)
        pulumi.set(__self__, "vrid", vrid)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The IP address of the gateway used by LoadBalancer.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        The list of IP address assigned to the LoadBalancer.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet assigned to the LoadBalancer.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch connected from the LoadBalancer.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def vrid(self) -> int:
        """
        The Virtual Router Identifier.
        """
        return pulumi.get(self, "vrid")


@pulumi.output_type
class GetLoadBalancerVipResult(dict):
    def __init__(__self__, *,
                 delay_loop: int,
                 description: str,
                 port: int,
                 servers: Sequence['outputs.GetLoadBalancerVipServerResult'],
                 sorry_server: str,
                 vip: str):
        """
        :param int delay_loop: The interval in seconds between checks.
        :param str description: The description of the VIP.
        :param int port: The target port number for load-balancing.
        :param Sequence['GetLoadBalancerVipServerArgs'] servers: A list of `server` blocks as defined below.
        :param str sorry_server: The IP address of the SorryServer. This will be used when all servers under this VIP are down.
        :param str vip: The virtual IP address.
        """
        pulumi.set(__self__, "delay_loop", delay_loop)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "sorry_server", sorry_server)
        pulumi.set(__self__, "vip", vip)

    @property
    @pulumi.getter(name="delayLoop")
    def delay_loop(self) -> int:
        """
        The interval in seconds between checks.
        """
        return pulumi.get(self, "delay_loop")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the VIP.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The target port number for load-balancing.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetLoadBalancerVipServerResult']:
        """
        A list of `server` blocks as defined below.
        """
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter(name="sorryServer")
    def sorry_server(self) -> str:
        """
        The IP address of the SorryServer. This will be used when all servers under this VIP are down.
        """
        return pulumi.get(self, "sorry_server")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The virtual IP address.
        """
        return pulumi.get(self, "vip")


@pulumi.output_type
class GetLoadBalancerVipServerResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 ip_address: str,
                 path: str,
                 protocol: str,
                 status: str):
        """
        :param bool enabled: The flag to enable as destination of load balancing.
        :param str ip_address: The IP address of the destination server.
        :param str path: The path used when checking by HTTP/HTTPS.
        :param str protocol: The protocol used for health checks. This will be one of [`http`/`https`/`tcp`/`ping`].
        :param str status: The response code to expect when checking by HTTP/HTTPS.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The flag to enable as destination of load balancing.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the destination server.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This will be one of [`http`/`https`/`tcp`/`ping`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The response code to expect when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLocalRouterFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetLocalRouterFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetLocalRouterFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetLocalRouterFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLocalRouterFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetLocalRouterNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 ip_addresses: Sequence[str],
                 netmask: int,
                 vip: str,
                 vrid: int):
        """
        :param Sequence[str] ip_addresses: The list of IP address assigned to the LocalRouter.
        :param int netmask: The bit length of the subnet assigned to the LocalRouter.
        :param str vip: The virtual IP address.
        :param int vrid: The Virtual Router Identifier.
        """
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vrid", vrid)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        The list of IP address assigned to the LocalRouter.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet assigned to the LocalRouter.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The virtual IP address.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter
    def vrid(self) -> int:
        """
        The Virtual Router Identifier.
        """
        return pulumi.get(self, "vrid")


@pulumi.output_type
class GetLocalRouterPeerResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 peer_id: str,
                 secret_key: str):
        """
        :param str description: The description of the LocalRouter.
        :param bool enabled: The flag to enable the LocalRouter.
        :param str peer_id: The ID of the peer LocalRouter.
        :param str secret_key: The secret key of the peer LocalRouter.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "peer_id", peer_id)
        pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the LocalRouter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The flag to enable the LocalRouter.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="peerId")
    def peer_id(self) -> str:
        """
        The ID of the peer LocalRouter.
        """
        return pulumi.get(self, "peer_id")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        The secret key of the peer LocalRouter.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetLocalRouterStaticRouteResult(dict):
    def __init__(__self__, *,
                 next_hop: str,
                 prefix: str):
        """
        :param str next_hop: The IP address of the next hop.
        :param str prefix: The CIDR block of destination.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The IP address of the next hop.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The CIDR block of destination.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetLocalRouterSwitchResult(dict):
    def __init__(__self__, *,
                 category: str,
                 code: str,
                 zone_id: str):
        """
        :param str category: The category name of connected services (e.g. `cloud`, `vps`).
        :param str code: The resource ID of the Switch.
        :param str zone_id: The id of the Zone.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category name of connected services (e.g. `cloud`, `vps`).
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        The resource ID of the Switch.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The id of the Zone.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetNFSFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetNFSFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetNFSFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetNFSFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNFSFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNFSNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 gateway: str,
                 ip_address: str,
                 netmask: int,
                 switch_id: str):
        """
        :param str gateway: The IP address of the gateway used by NFS.
        :param str ip_address: The IP address assigned to the NFS.
        :param int netmask: The bit length of the subnet assigned to the NFS.
        :param str switch_id: The id of the switch connected from the NFS.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The IP address of the gateway used by NFS.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address assigned to the NFS.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet assigned to the NFS.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch connected from the NFS.
        """
        return pulumi.get(self, "switch_id")


@pulumi.output_type
class GetNoteFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetNoteFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetNoteFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetNoteFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNoteFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPacketFilterExpressionResult(dict):
    def __init__(__self__, *,
                 allow: bool,
                 description: str,
                 destination_port: str,
                 protocol: str,
                 source_network: str,
                 source_port: str):
        """
        :param bool allow: The flag to allow the packet through the filter.
        :param str description: The description of the expression.
        :param str destination_port: A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        :param str protocol: The protocol used for filtering. This will be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`].
        :param str source_network: A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        :param str source_port: A source port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        pulumi.set(__self__, "allow", allow)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_network", source_network)
        pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def allow(self) -> bool:
        """
        The flag to allow the packet through the filter.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the expression.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> str:
        """
        A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for filtering. This will be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceNetwork")
    def source_network(self) -> str:
        """
        A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        """
        return pulumi.get(self, "source_network")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> str:
        """
        A source port number or port range used for filtering (e.g. `1024`, `1024-2048`).
        """
        return pulumi.get(self, "source_port")


@pulumi.output_type
class GetPacketFilterFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetPacketFilterFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetPacketFilterFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetPacketFilterFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class GetPacketFilterFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetPrivateHostFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetPrivateHostFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetPrivateHostFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetPrivateHostFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetPrivateHostFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetProxyLBBindPortResult(dict):
    def __init__(__self__, *,
                 port: int,
                 proxy_mode: str,
                 redirect_to_https: bool,
                 response_headers: Sequence['outputs.GetProxyLBBindPortResponseHeaderResult'],
                 ssl_policy: str,
                 support_http2: bool):
        """
        :param int port: The number of syslog port.
        :param str proxy_mode: The proxy mode. This will be one of [`http`/`https`/`tcp`].
        :param bool redirect_to_https: The flag to enable redirection from http to https. This flag is used only when `proxy_mode` is `http`.
        :param Sequence['GetProxyLBBindPortResponseHeaderArgs'] response_headers: A list of `response_header` blocks as defined below.
        :param bool support_http2: The flag to enable HTTP/2. This flag is used only when `proxy_mode` is `https`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "proxy_mode", proxy_mode)
        pulumi.set(__self__, "redirect_to_https", redirect_to_https)
        pulumi.set(__self__, "response_headers", response_headers)
        pulumi.set(__self__, "ssl_policy", ssl_policy)
        pulumi.set(__self__, "support_http2", support_http2)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The number of syslog port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="proxyMode")
    def proxy_mode(self) -> str:
        """
        The proxy mode. This will be one of [`http`/`https`/`tcp`].
        """
        return pulumi.get(self, "proxy_mode")

    @property
    @pulumi.getter(name="redirectToHttps")
    def redirect_to_https(self) -> bool:
        """
        The flag to enable redirection from http to https. This flag is used only when `proxy_mode` is `http`.
        """
        return pulumi.get(self, "redirect_to_https")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Sequence['outputs.GetProxyLBBindPortResponseHeaderResult']:
        """
        A list of `response_header` blocks as defined below.
        """
        return pulumi.get(self, "response_headers")

    @property
    @pulumi.getter(name="sslPolicy")
    def ssl_policy(self) -> str:
        return pulumi.get(self, "ssl_policy")

    @property
    @pulumi.getter(name="supportHttp2")
    def support_http2(self) -> bool:
        """
        The flag to enable HTTP/2. This flag is used only when `proxy_mode` is `https`.
        """
        return pulumi.get(self, "support_http2")


@pulumi.output_type
class GetProxyLBBindPortResponseHeaderResult(dict):
    def __init__(__self__, *,
                 header: str,
                 value: str):
        """
        :param str header: The field name of HTTP header added to response by the ProxyLB.
        :param str value: The field value of HTTP header added to response by the ProxyLB.
        """
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        The field name of HTTP header added to response by the ProxyLB.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The field value of HTTP header added to response by the ProxyLB.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProxyLBCertificateResult(dict):
    def __init__(__self__, *,
                 additional_certificates: Sequence['outputs.GetProxyLBCertificateAdditionalCertificateResult'],
                 common_name: str,
                 intermediate_cert: str,
                 private_key: str,
                 server_cert: str,
                 subject_alt_names: str):
        """
        :param Sequence['GetProxyLBCertificateAdditionalCertificateArgs'] additional_certificates: A list of `additional_certificate` blocks as defined below.
        :param str common_name: The common name of the certificate.
        :param str intermediate_cert: The intermediate certificate for a server.
        :param str private_key: The private key for a server.
        :param str server_cert: The certificate for a server.
        :param str subject_alt_names: The subject alternative names of the certificate.
        """
        pulumi.set(__self__, "additional_certificates", additional_certificates)
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "intermediate_cert", intermediate_cert)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "server_cert", server_cert)
        pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="additionalCertificates")
    def additional_certificates(self) -> Sequence['outputs.GetProxyLBCertificateAdditionalCertificateResult']:
        """
        A list of `additional_certificate` blocks as defined below.
        """
        return pulumi.get(self, "additional_certificates")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        The common name of the certificate.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="intermediateCert")
    def intermediate_cert(self) -> str:
        """
        The intermediate certificate for a server.
        """
        return pulumi.get(self, "intermediate_cert")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        The private key for a server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> str:
        """
        The certificate for a server.
        """
        return pulumi.get(self, "server_cert")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> str:
        """
        The subject alternative names of the certificate.
        """
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class GetProxyLBCertificateAdditionalCertificateResult(dict):
    def __init__(__self__, *,
                 intermediate_cert: str,
                 private_key: str,
                 server_cert: str):
        """
        :param str intermediate_cert: The intermediate certificate for a server.
        :param str private_key: The private key for a server.
        :param str server_cert: The certificate for a server.
        """
        pulumi.set(__self__, "intermediate_cert", intermediate_cert)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "server_cert", server_cert)

    @property
    @pulumi.getter(name="intermediateCert")
    def intermediate_cert(self) -> str:
        """
        The intermediate certificate for a server.
        """
        return pulumi.get(self, "intermediate_cert")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        The private key for a server.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCert")
    def server_cert(self) -> str:
        """
        The certificate for a server.
        """
        return pulumi.get(self, "server_cert")


@pulumi.output_type
class GetProxyLBFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetProxyLBFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetProxyLBFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetProxyLBFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetProxyLBFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetProxyLBHealthCheckResult(dict):
    def __init__(__self__, *,
                 delay_loop: int,
                 host_header: str,
                 path: str,
                 port: int,
                 protocol: str):
        """
        :param int delay_loop: The interval in seconds between checks.
        :param str host_header: The value of host header send when checking by HTTP.
        :param str path: The request path that is used as condition of rule-based balancing.
        :param int port: The number of syslog port.
        :param str protocol: The protocol used for health checks. This will be one of [`http`/`tcp`].
        """
        pulumi.set(__self__, "delay_loop", delay_loop)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="delayLoop")
    def delay_loop(self) -> int:
        """
        The interval in seconds between checks.
        """
        return pulumi.get(self, "delay_loop")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The value of host header send when checking by HTTP.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The request path that is used as condition of rule-based balancing.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The number of syslog port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This will be one of [`http`/`tcp`].
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetProxyLBRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 fixed_content_type: str,
                 fixed_message_body: str,
                 fixed_status_code: str,
                 group: str,
                 host: str,
                 path: str,
                 redirect_location: str,
                 redirect_status_code: str):
        """
        :param str action: The type of action to be performed when requests matches the rule. This will be one of [`forward`/`redirect`/`fixed`].
        :param str fixed_content_type: Content-Type header value for fixed response sent when requests matches the rule. This will be one of [`text/plain`/`text/html`/`application/javascript`/`application/json`].
        :param str fixed_message_body: Content body for fixed response sent when requests matches the rule.
        :param str fixed_status_code: HTTP status code for fixed response sent when requests matches the rule. This will be one of [`200`/`403`/`503`].
        :param str group: The name of load balancing group. This is used when using rule-based load balancing.
        :param str host: The value of HTTP host header that is used as condition of rule-based balancing.
        :param str path: The request path that is used as condition of rule-based balancing.
        :param str redirect_location: The URL to redirect to when the request matches the rule. see https://manual.sakura.ad.jp/cloud/appliance/enhanced-lb/#enhanced-lb-rule for details.
        :param str redirect_status_code: HTTP status code for redirects sent when requests matches the rule. This will be one of [`301`/`302`].
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "fixed_content_type", fixed_content_type)
        pulumi.set(__self__, "fixed_message_body", fixed_message_body)
        pulumi.set(__self__, "fixed_status_code", fixed_status_code)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "redirect_location", redirect_location)
        pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of action to be performed when requests matches the rule. This will be one of [`forward`/`redirect`/`fixed`].
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="fixedContentType")
    def fixed_content_type(self) -> str:
        """
        Content-Type header value for fixed response sent when requests matches the rule. This will be one of [`text/plain`/`text/html`/`application/javascript`/`application/json`].
        """
        return pulumi.get(self, "fixed_content_type")

    @property
    @pulumi.getter(name="fixedMessageBody")
    def fixed_message_body(self) -> str:
        """
        Content body for fixed response sent when requests matches the rule.
        """
        return pulumi.get(self, "fixed_message_body")

    @property
    @pulumi.getter(name="fixedStatusCode")
    def fixed_status_code(self) -> str:
        """
        HTTP status code for fixed response sent when requests matches the rule. This will be one of [`200`/`403`/`503`].
        """
        return pulumi.get(self, "fixed_status_code")

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        The name of load balancing group. This is used when using rule-based load balancing.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The value of HTTP host header that is used as condition of rule-based balancing.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The request path that is used as condition of rule-based balancing.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="redirectLocation")
    def redirect_location(self) -> str:
        """
        The URL to redirect to when the request matches the rule. see https://manual.sakura.ad.jp/cloud/appliance/enhanced-lb/#enhanced-lb-rule for details.
        """
        return pulumi.get(self, "redirect_location")

    @property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> str:
        """
        HTTP status code for redirects sent when requests matches the rule. This will be one of [`301`/`302`].
        """
        return pulumi.get(self, "redirect_status_code")


@pulumi.output_type
class GetProxyLBServerResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 group: str,
                 ip_address: str,
                 port: int):
        """
        :param bool enabled: The flag to enable as destination of load balancing.
        :param str group: The name of load balancing group. This is used when using rule-based load balancing.
        :param str ip_address: The IP address of the SorryServer. This will be used when all servers are down.
        :param int port: The number of syslog port.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The flag to enable as destination of load balancing.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        The name of load balancing group. This is used when using rule-based load balancing.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the SorryServer. This will be used when all servers are down.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The number of syslog port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetProxyLBSorryServerResult(dict):
    def __init__(__self__, *,
                 ip_address: str,
                 port: int):
        """
        :param str ip_address: The IP address of the SorryServer. This will be used when all servers are down.
        :param int port: The number of syslog port.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the SorryServer. This will be used when all servers are down.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The number of syslog port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetProxyLBSyslogResult(dict):
    def __init__(__self__, *,
                 port: int,
                 server: str):
        """
        :param int port: The number of syslog port.
        :param str server: The address of syslog server.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The number of syslog port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The address of syslog server.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetSSHKeyFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetSSHKeyFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetSSHKeyFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetSSHKeyFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class GetSSHKeyFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetServerFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetServerFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetServerFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetServerFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetServerFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetServerNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 mac_address: str,
                 packet_filter_id: str,
                 upstream: str,
                 user_ip_address: str):
        """
        :param str mac_address: The MAC address.
        :param str packet_filter_id: The id of the packet filter attached to the network interface.
        :param str upstream: The upstream type or upstream switch id. This will be one of [`shared`/`disconnect`/`<switch id>`].
        :param str user_ip_address: The IP address for only display. This value doesn't affect actual NIC settings.
        """
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "packet_filter_id", packet_filter_id)
        pulumi.set(__self__, "upstream", upstream)
        pulumi.set(__self__, "user_ip_address", user_ip_address)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The MAC address.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="packetFilterId")
    def packet_filter_id(self) -> str:
        """
        The id of the packet filter attached to the network interface.
        """
        return pulumi.get(self, "packet_filter_id")

    @property
    @pulumi.getter
    def upstream(self) -> str:
        """
        The upstream type or upstream switch id. This will be one of [`shared`/`disconnect`/`<switch id>`].
        """
        return pulumi.get(self, "upstream")

    @property
    @pulumi.getter(name="userIpAddress")
    def user_ip_address(self) -> str:
        """
        The IP address for only display. This value doesn't affect actual NIC settings.
        """
        return pulumi.get(self, "user_ip_address")


@pulumi.output_type
class GetSimpleMonitorFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetSimpleMonitorFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetSimpleMonitorFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetSimpleMonitorFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSimpleMonitorFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSimpleMonitorHealthCheckResult(dict):
    def __init__(__self__, *,
                 community: str,
                 contains_string: str,
                 excepcted_data: str,
                 ftps: str,
                 host_header: str,
                 http2: bool,
                 oid: str,
                 password: str,
                 path: str,
                 port: int,
                 protocol: str,
                 qname: str,
                 remaining_days: int,
                 sni: bool,
                 snmp_version: str,
                 status: int,
                 username: str):
        """
        :param str community: The SNMP community string used when checking by SNMP.
        :param str contains_string: The string that should be included in the response body when checking for HTTP/HTTPS.
        :param str excepcted_data: The expected value used when checking by DNS.
        :param str ftps: The methods of invoking security for monitoring with FTPS. This will be one of [``/`implicit`/`explicit`].
        :param str host_header: The value of host header send when checking by HTTP/HTTPS.
        :param bool http2: The flag to enable HTTP/2 when checking by HTTPS.
        :param str oid: The SNMP OID used when checking by SNMP.
        :param str password: The password for basic auth used when checking by HTTP/HTTPS.
        :param str path: The path used when checking by HTTP/HTTPS.
        :param int port: The target port number.
        :param str protocol: The protocol used for health checks. This will be one of [`http`/`https`/`ping`/`tcp`/`dns`/`ssh`/`smtp`/`pop3`/`snmp`/`sslcertificate`/`ftp`].
        :param str qname: The FQDN used when checking by DNS.
        :param int remaining_days: The number of remaining days until certificate expiration used when checking SSL certificates.
        :param bool sni: The flag to enable SNI when checking by HTTP/HTTPS.
        :param str snmp_version: The SNMP version used when checking by SNMP.
        :param int status: The response-code to expect when checking by HTTP/HTTPS.
        :param str username: The user name for basic auth used when checking by HTTP/HTTPS.
        """
        pulumi.set(__self__, "community", community)
        pulumi.set(__self__, "contains_string", contains_string)
        pulumi.set(__self__, "excepcted_data", excepcted_data)
        pulumi.set(__self__, "ftps", ftps)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "oid", oid)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "qname", qname)
        pulumi.set(__self__, "remaining_days", remaining_days)
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "snmp_version", snmp_version)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def community(self) -> str:
        """
        The SNMP community string used when checking by SNMP.
        """
        return pulumi.get(self, "community")

    @property
    @pulumi.getter(name="containsString")
    def contains_string(self) -> str:
        """
        The string that should be included in the response body when checking for HTTP/HTTPS.
        """
        return pulumi.get(self, "contains_string")

    @property
    @pulumi.getter(name="excepctedData")
    def excepcted_data(self) -> str:
        """
        The expected value used when checking by DNS.
        """
        return pulumi.get(self, "excepcted_data")

    @property
    @pulumi.getter
    def ftps(self) -> str:
        """
        The methods of invoking security for monitoring with FTPS. This will be one of [``/`implicit`/`explicit`].
        """
        return pulumi.get(self, "ftps")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The value of host header send when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def http2(self) -> bool:
        """
        The flag to enable HTTP/2 when checking by HTTPS.
        """
        return pulumi.get(self, "http2")

    @property
    @pulumi.getter
    def oid(self) -> str:
        """
        The SNMP OID used when checking by SNMP.
        """
        return pulumi.get(self, "oid")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password for basic auth used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The target port number.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for health checks. This will be one of [`http`/`https`/`ping`/`tcp`/`dns`/`ssh`/`smtp`/`pop3`/`snmp`/`sslcertificate`/`ftp`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def qname(self) -> str:
        """
        The FQDN used when checking by DNS.
        """
        return pulumi.get(self, "qname")

    @property
    @pulumi.getter(name="remainingDays")
    def remaining_days(self) -> int:
        """
        The number of remaining days until certificate expiration used when checking SSL certificates.
        """
        return pulumi.get(self, "remaining_days")

    @property
    @pulumi.getter
    def sni(self) -> bool:
        """
        The flag to enable SNI when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="snmpVersion")
    def snmp_version(self) -> str:
        """
        The SNMP version used when checking by SNMP.
        """
        return pulumi.get(self, "snmp_version")

    @property
    @pulumi.getter
    def status(self) -> int:
        """
        The response-code to expect when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The user name for basic auth used when checking by HTTP/HTTPS.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetSwitchFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetSwitchFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetSwitchFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetSwitchFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSwitchFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVPCRouterDhcpServerResult(dict):
    def __init__(__self__, *,
                 dns_servers: Sequence[str],
                 interface_index: int,
                 range_start: str,
                 range_stop: str):
        """
        :param Sequence[str] dns_servers: A list of IP address of DNS server to assign to DHCP client.
        :param int interface_index: The index of the network interface on which to enable filtering. This will be between `0`-`7`.
        :param str range_start: The start value of IP address range to assign to PPTP client.
        :param str range_stop: The end value of IP address range to assign to PPTP client.
        """
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "interface_index", interface_index)
        pulumi.set(__self__, "range_start", range_start)
        pulumi.set(__self__, "range_stop", range_stop)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        A list of IP address of DNS server to assign to DHCP client.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="interfaceIndex")
    def interface_index(self) -> int:
        """
        The index of the network interface on which to enable filtering. This will be between `0`-`7`.
        """
        return pulumi.get(self, "interface_index")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> str:
        """
        The start value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter(name="rangeStop")
    def range_stop(self) -> str:
        """
        The end value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_stop")


@pulumi.output_type
class GetVPCRouterDhcpStaticMappingResult(dict):
    def __init__(__self__, *,
                 ip_address: str,
                 mac_address: str):
        """
        :param str ip_address: The IP address for peer.
        :param str mac_address: The source MAC address of static mapping.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address for peer.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The source MAC address of static mapping.
        """
        return pulumi.get(self, "mac_address")


@pulumi.output_type
class GetVPCRouterFilterResult(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GetVPCRouterFilterConditionResult']] = None,
                 id: Optional[str] = None,
                 names: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetVPCRouterFilterConditionArgs'] conditions: One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        :param str id: The resource id on SakuraCloud used for filtering.
        :param Sequence[str] names: The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        :param Sequence[str] tags: The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GetVPCRouterFilterConditionResult']]:
        """
        One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/).
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource id on SakuraCloud used for filtering.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetVPCRouterFilterConditionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param Sequence[str] values: The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the condition. If multiple values ​​are specified, they combined as AND condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetVPCRouterFirewallResult(dict):
    def __init__(__self__, *,
                 direction: str,
                 expressions: Sequence['outputs.GetVPCRouterFirewallExpressionResult'],
                 interface_index: int):
        """
        :param str direction: The direction to apply the firewall. This will be one of [`send`/`receive`].
        :param Sequence['GetVPCRouterFirewallExpressionArgs'] expressions: A list of `expression` blocks as defined below.
        :param int interface_index: The index of the network interface on which to enable filtering. This will be between `0`-`7`.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "expressions", expressions)
        pulumi.set(__self__, "interface_index", interface_index)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction to apply the firewall. This will be one of [`send`/`receive`].
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['outputs.GetVPCRouterFirewallExpressionResult']:
        """
        A list of `expression` blocks as defined below.
        """
        return pulumi.get(self, "expressions")

    @property
    @pulumi.getter(name="interfaceIndex")
    def interface_index(self) -> int:
        """
        The index of the network interface on which to enable filtering. This will be between `0`-`7`.
        """
        return pulumi.get(self, "interface_index")


@pulumi.output_type
class GetVPCRouterFirewallExpressionResult(dict):
    def __init__(__self__, *,
                 allow: bool,
                 description: str,
                 destination_network: str,
                 destination_port: str,
                 logging: bool,
                 protocol: str,
                 source_network: str,
                 source_port: str):
        """
        :param bool allow: The flag to allow the packet through the filter.
        :param str description: The description of the static NAT.
        :param str destination_network: A destination IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        :param str destination_port: A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        :param bool logging: The flag to enable packet logging when matching the expression.
        :param str protocol: The protocol used for port forwarding. This will be one of [`tcp`/`udp`].
        :param str source_network: A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        :param str source_port: A source port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        """
        pulumi.set(__self__, "allow", allow)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destination_network", destination_network)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_network", source_network)
        pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def allow(self) -> bool:
        """
        The flag to allow the packet through the filter.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the static NAT.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationNetwork")
    def destination_network(self) -> str:
        """
        A destination IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        """
        return pulumi.get(self, "destination_network")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> str:
        """
        A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def logging(self) -> bool:
        """
        The flag to enable packet logging when matching the expression.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for port forwarding. This will be one of [`tcp`/`udp`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceNetwork")
    def source_network(self) -> str:
        """
        A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`).
        """
        return pulumi.get(self, "source_network")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> str:
        """
        A source port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`.
        """
        return pulumi.get(self, "source_port")


@pulumi.output_type
class GetVPCRouterL2tpResult(dict):
    def __init__(__self__, *,
                 pre_shared_secret: str,
                 range_start: str,
                 range_stop: str):
        """
        :param str pre_shared_secret: The pre shared secret for the VPN.
        :param str range_start: The start value of IP address range to assign to PPTP client.
        :param str range_stop: The end value of IP address range to assign to PPTP client.
        """
        pulumi.set(__self__, "pre_shared_secret", pre_shared_secret)
        pulumi.set(__self__, "range_start", range_start)
        pulumi.set(__self__, "range_stop", range_stop)

    @property
    @pulumi.getter(name="preSharedSecret")
    def pre_shared_secret(self) -> str:
        """
        The pre shared secret for the VPN.
        """
        return pulumi.get(self, "pre_shared_secret")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> str:
        """
        The start value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter(name="rangeStop")
    def range_stop(self) -> str:
        """
        The end value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_stop")


@pulumi.output_type
class GetVPCRouterPortForwardingResult(dict):
    def __init__(__self__, *,
                 description: str,
                 private_ip: str,
                 private_port: int,
                 protocol: str,
                 public_port: int):
        """
        :param str description: The description of the static NAT.
        :param str private_ip: The private IP address used for the static NAT.
        :param int private_port: The destination port number of the port forwarding. This will be a port number on a private network.
        :param str protocol: The protocol used for port forwarding. This will be one of [`tcp`/`udp`].
        :param int public_port: The source port number of the port forwarding. This will be a port number on a public network.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "private_port", private_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "public_port", public_port)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the static NAT.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address used for the static NAT.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="privatePort")
    def private_port(self) -> int:
        """
        The destination port number of the port forwarding. This will be a port number on a private network.
        """
        return pulumi.get(self, "private_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used for port forwarding. This will be one of [`tcp`/`udp`].
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> int:
        """
        The source port number of the port forwarding. This will be a port number on a public network.
        """
        return pulumi.get(self, "public_port")


@pulumi.output_type
class GetVPCRouterPptpResult(dict):
    def __init__(__self__, *,
                 range_start: str,
                 range_stop: str):
        """
        :param str range_start: The start value of IP address range to assign to PPTP client.
        :param str range_stop: The end value of IP address range to assign to PPTP client.
        """
        pulumi.set(__self__, "range_start", range_start)
        pulumi.set(__self__, "range_stop", range_stop)

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> str:
        """
        The start value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter(name="rangeStop")
    def range_stop(self) -> str:
        """
        The end value of IP address range to assign to PPTP client.
        """
        return pulumi.get(self, "range_stop")


@pulumi.output_type
class GetVPCRouterPrivateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 index: int,
                 ip_addresses: Sequence[str],
                 netmask: int,
                 switch_id: str,
                 vip: str):
        """
        :param int index: The index of the network interface. This will be between `1`-`7`.
        :param Sequence[str] ip_addresses: The list of the IP address assigned to the VPC Router. This will be only one value when `plan` is `standard`, two values otherwise.
        :param int netmask: The bit length of the subnet assigned to the network interface.
        :param str switch_id: The id of the switch connected from the VPCRouter.
        :param str vip: The virtual IP address of the VPC Router. This is only used when `plan` is not `standard`.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "switch_id", switch_id)
        pulumi.set(__self__, "vip", vip)

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The index of the network interface. This will be between `1`-`7`.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        The list of the IP address assigned to the VPC Router. This will be only one value when `plan` is `standard`, two values otherwise.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def netmask(self) -> int:
        """
        The bit length of the subnet assigned to the network interface.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch connected from the VPCRouter.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The virtual IP address of the VPC Router. This is only used when `plan` is not `standard`.
        """
        return pulumi.get(self, "vip")


@pulumi.output_type
class GetVPCRouterPublicNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 aliases: Sequence[str],
                 ip_addresses: Sequence[str],
                 switch_id: str,
                 vip: str,
                 vrid: int):
        """
        :param Sequence[str] aliases: A list of ip alias assigned to the VPC Router. This is only used when `plan` is not `standard`.
        :param Sequence[str] ip_addresses: The list of the IP address assigned to the VPC Router. This will be only one value when `plan` is `standard`, two values otherwise.
        :param str switch_id: The id of the switch connected from the VPCRouter.
        :param str vip: The virtual IP address of the VPC Router. This is only used when `plan` is not `standard`.
        :param int vrid: The Virtual Router Identifier. This is only used when `plan` is not `standard`.
        """
        pulumi.set(__self__, "aliases", aliases)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "switch_id", switch_id)
        pulumi.set(__self__, "vip", vip)
        pulumi.set(__self__, "vrid", vrid)

    @property
    @pulumi.getter
    def aliases(self) -> Sequence[str]:
        """
        A list of ip alias assigned to the VPC Router. This is only used when `plan` is not `standard`.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        The list of the IP address assigned to the VPC Router. This will be only one value when `plan` is `standard`, two values otherwise.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> str:
        """
        The id of the switch connected from the VPCRouter.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The virtual IP address of the VPC Router. This is only used when `plan` is not `standard`.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter
    def vrid(self) -> int:
        """
        The Virtual Router Identifier. This is only used when `plan` is not `standard`.
        """
        return pulumi.get(self, "vrid")


@pulumi.output_type
class GetVPCRouterSiteToSiteVpnResult(dict):
    def __init__(__self__, *,
                 local_prefixes: Sequence[str],
                 peer: str,
                 pre_shared_secret: str,
                 remote_id: str,
                 routes: Sequence[str]):
        """
        :param Sequence[str] local_prefixes: A list of CIDR block of the network under the VPC Router.
        :param str peer: A list of `peer` blocks as defined below.
        :param str pre_shared_secret: The pre shared secret for the VPN.
        :param str remote_id: The id of the opposing appliance connected to the VPC Router. This is typically set same as value of `peer`.
        :param Sequence[str] routes: A list of CIDR block of VPN connected networks.
        """
        pulumi.set(__self__, "local_prefixes", local_prefixes)
        pulumi.set(__self__, "peer", peer)
        pulumi.set(__self__, "pre_shared_secret", pre_shared_secret)
        pulumi.set(__self__, "remote_id", remote_id)
        pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter(name="localPrefixes")
    def local_prefixes(self) -> Sequence[str]:
        """
        A list of CIDR block of the network under the VPC Router.
        """
        return pulumi.get(self, "local_prefixes")

    @property
    @pulumi.getter
    def peer(self) -> str:
        """
        A list of `peer` blocks as defined below.
        """
        return pulumi.get(self, "peer")

    @property
    @pulumi.getter(name="preSharedSecret")
    def pre_shared_secret(self) -> str:
        """
        The pre shared secret for the VPN.
        """
        return pulumi.get(self, "pre_shared_secret")

    @property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> str:
        """
        The id of the opposing appliance connected to the VPC Router. This is typically set same as value of `peer`.
        """
        return pulumi.get(self, "remote_id")

    @property
    @pulumi.getter
    def routes(self) -> Sequence[str]:
        """
        A list of CIDR block of VPN connected networks.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class GetVPCRouterStaticNatResult(dict):
    def __init__(__self__, *,
                 description: str,
                 private_ip: str,
                 public_ip: str):
        """
        :param str description: The description of the static NAT.
        :param str private_ip: The private IP address used for the static NAT.
        :param str public_ip: The public IP address used for the static NAT.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "public_ip", public_ip)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the static NAT.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The private IP address used for the static NAT.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IP address used for the static NAT.
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class GetVPCRouterStaticRouteResult(dict):
    def __init__(__self__, *,
                 next_hop: str,
                 prefix: str):
        """
        :param str next_hop: The IP address of the next hop.
        :param str prefix: The CIDR block of destination.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> str:
        """
        The IP address of the next hop.
        """
        return pulumi.get(self, "next_hop")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The CIDR block of destination.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetVPCRouterUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 password: str):
        """
        :param str name: The name of the target field. This value is case-sensitive.
        :param str password: The password used to authenticate remote access.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password used to authenticate remote access.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetVPCRouterWireGuardResult(dict):
    def __init__(__self__, *,
                 ip_address: str,
                 peers: Sequence['outputs.GetVPCRouterWireGuardPeerResult'],
                 public_key: str):
        """
        :param str ip_address: The IP address for peer.
        :param Sequence['GetVPCRouterWireGuardPeerArgs'] peers: A list of `peer` blocks as defined below.
        :param str public_key: the public key of the WireGuard client.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "peers", peers)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address for peer.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def peers(self) -> Sequence['outputs.GetVPCRouterWireGuardPeerResult']:
        """
        A list of `peer` blocks as defined below.
        """
        return pulumi.get(self, "peers")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        the public key of the WireGuard client.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetVPCRouterWireGuardPeerResult(dict):
    def __init__(__self__, *,
                 ip_address: str,
                 name: str,
                 public_key: str):
        """
        :param str ip_address: The IP address for peer.
        :param str name: The name of the target field. This value is case-sensitive.
        :param str public_key: the public key of the WireGuard client.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address for peer.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the target field. This value is case-sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        the public key of the WireGuard client.
        """
        return pulumi.get(self, "public_key")


